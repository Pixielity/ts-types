{"version":3,"sources":["../../../../src/interfaces/console/command/command.interface.ts","../../../../src/interfaces/console/command/registry.interface.ts","../../../../src/interfaces/console/command/collector.interface.ts","../../../../src/interfaces/console/command/scheduler.interface.ts"],"names":["ICommand","ICommandRegistry","ICommandCollector","ICommandScheduler"],"mappings":";;;;;;;;;;;;;AAkLiBA;AAAA,CAAV,CAAUA,SAAV,KAAA;AAKE,EAAMA,SAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,UAAU,CAAA;AAAA,CALnB,EAAAA,gBAAA,KAAAA,gBAAA,GAAA,EAAA,CAAA,CAAA;;;ACxHAC;AAAA,CAAV,CAAUA,iBAAV,KAAA;AAKE,EAAMA,iBAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,kBAAkB,CAAA;AAAA,CAL3B,EAAAA,wBAAA,KAAAA,wBAAA,GAAA,EAAA,CAAA,CAAA;;;ACpBAC;AAAA,CAAV,CAAUA,kBAAV,KAAA;AAKE,EAAMA,kBAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,mBAAmB,CAAA;AAAA,CAL5B,EAAAA,yBAAA,KAAAA,yBAAA,GAAA,EAAA,CAAA,CAAA;;;ACsBAC;AAAA,CAAV,CAAUA,kBAAV,KAAA;AAKE,EAAMA,kBAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,mBAAmB,CAAA;AAAA,CAL5B,EAAAA,yBAAA,KAAAA,yBAAA,GAAA,EAAA,CAAA,CAAA","file":"index.js","sourcesContent":["import type { IInput } from '../input.interface'\nimport type { IOutput } from '../output.interface'\n\nimport { IAsk } from '../ui/ask.interface'\nimport { ITableStyle } from '../ui/table-style.interface'\nimport { IProgressBar } from '../ui/progress-bar.interface'\nimport { ITableOutput } from '../ui/table-output.interface'\nimport { IProgressBarFormat } from '../ui/progress-bar-format.interface'\n\n/**\n * Interface for console command classes.\n *\n * Defines the structure and lifecycle of a command,\n * including argument/option handling and execution hooks.\n */\nexport interface ICommand {\n  /**\n   * Gets the name of the command.\n   *\n   * @returns The command name.\n   */\n  getName(): string\n\n  /**\n   * Gets the description of the command.\n   *\n   * @returns The command description.\n   */\n  getDescription(): string\n\n  /**\n   * Sets the input instance for the command.\n   *\n   * @param input - The input instance to set.\n   */\n  setInput(input: IInput): void\n\n  /**\n   * Gets the current input instance.\n   *\n   * @returns The input instance.\n   */\n  getInput(): IInput\n\n  /**\n   * Sets the output instance for the command.\n   *\n   * @param output - The output instance to set.\n   */\n  setOutput(output: IOutput): void\n\n  /**\n   * Gets the current output instance.\n   *\n   * @returns The output instance.\n   */\n  getOutput(): IOutput\n\n  /**\n   * Sets multiple arguments by index or name.\n   *\n   * @param args - Array of positional arguments.\n   */\n  setArguments(args: string[]): void\n\n  /**\n   * Sets a single named argument.\n   *\n   * @param key - Argument key.\n   * @param value - Argument value.\n   */\n  setArgument(key: string, value: any): void\n\n  /**\n   * Gets all arguments.\n   *\n   * @returns A key-value map of arguments.\n   */\n  getArguments(): Record<string, any>\n\n  /**\n   * Retrieves a single argument by name.\n   *\n   * @param key - The argument name.\n   * @param defaultValue - default value .\n   * @returns The value of the argument or undefined if not found.\n   */\n  getArgument<T = any>(key: string, defaultValue?: T): T | undefined\n\n  /**\n   * Sets multiple options by key.\n   *\n   * @param options - Key-value map of options.\n   */\n  setOptions(options: Record<string, any>): void\n\n  /**\n   * Sets a single option.\n   *\n   * @param key - Option key.\n   * @param value - Option value.\n   */\n  setOption(key: string, value: any): void\n\n  /**\n   * Gets all options.\n   *\n   * @returns A key-value map of options.\n   */\n  getOptions(): Record<string, any>\n\n  /**\n   * Retrieves a single option by name.\n   *\n   * @param key - The option name.\n   * @param defaultValue - default value .\n   * @returns The value of the option or undefined if not found.\n   */\n  getOption<T = any>(key: string, defaultValue?: T): T | undefined\n\n  /**\n   * Allows a command to define its expected arguments and options.\n   * Called before execution.\n   */\n  configure(): void\n\n  /**\n   * Main execution logic of the command.\n   * Must return a status code (or void).\n   *\n   * @returns Promise resolving to exit code or void.\n   */\n  execute(): Promise<number | void>\n\n  /**\n   * Hook called before command execution.\n   * Return false to cancel execution.\n   *\n   * @returns Whether to continue execution.\n   */\n  beforeExecute(): Promise<boolean>\n\n  /**\n   * Hook called after command execution.\n   *\n   * @param exitCode - The result from execute().\n   */\n  afterExecute(exitCode: number | void): Promise<void>\n\n  /**\n   * Ask utility class\n   *\n   * @returns Ask utility class\n   */\n  ask(): IAsk\n\n  /**\n   * Creates a new ProgressBar instance\n   *\n   * @param {number} total - The total value\n   * @param {IProgressBarFormat} format - The format options\n   */\n  progress(total: number, format?: IProgressBarFormat): IProgressBar\n\n  /**\n   * Creates a new TableOutput instance\n   *\n   * @param {string[]} headers - The table headers\n   * @param {ITableStyle} style - The table style\n   */\n  table(headers: string[], style?: ITableStyle): ITableOutput\n}\n\n/**\n * Namespace for ICommand interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommand {\n  /**\n   * Token for the ICommand interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommand')\n}\n","import type { ICommand } from './command.interface'\n\n/**\n * Interface for the command registry\n *\n * Stores and manages all registered commands.\n */\nexport interface ICommandRegistry {\n  /**\n   * Adds a command to the registry\n   *\n   * @param {ICommand} command - The command to add\n   * @throws {Error} If a command with the same name already exists\n   */\n  add(command: ICommand): void\n\n  /**\n   * Gets a command by name\n   *\n   * @param {string} name - The name of the command\n   * @returns {ICommand | undefined} The command or undefined if not found\n   */\n  get(name: string): ICommand | undefined\n\n  /**\n   * Gets all registered commands\n   *\n   * @returns {ICommand[]} Array of all registered commands\n   */\n  getAll(): ICommand[]\n\n  /**\n   * Checks if a command exists\n   *\n   * @param {string} name - The name of the command\n   * @returns {boolean} True if the command exists, false otherwise\n   */\n  has(name: string): boolean\n\n  /**\n   * Removes a command from the registry\n   *\n   * @param {string} name - The name of the command\n   * @returns {boolean} True if the command was removed, false otherwise\n   */\n  remove(name: string): boolean\n\n  /**\n   * Clears all commands from the registry\n   */\n  clear(): void\n}\n\n/**\n * Namespace for ICommandRegistry interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandRegistry {\n  /**\n   * Token for the ICommandRegistry interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandRegistry')\n}\n","import type { ICommand } from './command.interface'\n\n/**\n * Interface for command collector\n *\n * Discovers and collects commands from the file system.\n */\nexport interface ICommandCollector {\n  /**\n   * Discovers commands in the specified directory\n   *\n   * @param {string} directory - The directory to scan for commands\n   * @param {string} pattern - The glob pattern to match command files\n   * @returns {Promise<ICommand[]>} The discovered commands\n   */\n  discoverCommands(directory: string, pattern?: string): Promise<ICommand[]>\n\n  /**\n   * Gets all commands that have been registered with the container\n   *\n   * @returns {ICommand[]} The registered commands\n   */\n  getRegisteredCommands(): ICommand[]\n\n  /**\n   * Gets command metadata for a command class\n   *\n   * @param {Function} commandClass - The command class\n   * @returns {any} The command metadata\n   */\n  getCommandMetadata(commandClass: Function): any\n}\n\n/**\n * Namespace for ICommandCollector interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandCollector {\n  /**\n   * Token for the ICommandCollector interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandCollector')\n}\n","import type { IScheduledTask } from '../schedule/task.interface'\nimport type { IScheduleExpression } from '../schedule/expression.interface'\n\n/**\n * Interface for the command scheduler\n *\n * Schedules commands to run at specific intervals.\n */\nexport interface ICommandScheduler {\n  /**\n   * Schedules a command to run at a specific interval\n   *\n   * @param {string} commandName - The name of the command\n   * @param {IScheduleExpression} expression - The schedule expression\n   * @param {string[]} args - The arguments to pass to the command\n   * @param {Record<string, any>} options - The options to pass to the command\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  schedule(\n    commandName: string,\n    expression: IScheduleExpression,\n    args?: string[],\n    options?: Record<string, any>,\n  ): ICommandScheduler\n\n  /**\n   * Starts the scheduler\n   *\n   * @param {number} interval - The interval in milliseconds to check for tasks to run\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  start(interval?: number): ICommandScheduler\n\n  /**\n   * Stops the scheduler\n   *\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  stop(): ICommandScheduler\n\n  /**\n   * Gets all scheduled tasks\n   *\n   * @returns {IScheduledTask[]} The scheduled tasks\n   */\n  getTasks(): IScheduledTask[]\n\n  /**\n   * Clears all scheduled tasks\n   *\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  clearTasks(): ICommandScheduler\n}\n\n/**\n * Namespace for ICommandScheduler interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandScheduler {\n  /**\n   * Token for the ICommandScheduler interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandScheduler')\n}\n"]}