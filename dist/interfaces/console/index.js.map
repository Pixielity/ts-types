{"version":3,"sources":["../../../src/interfaces/console/input.interface.ts","../../../src/interfaces/console/output.interface.ts","../../../src/interfaces/console/stub-generator.interface.ts","../../../src/interfaces/console/application.interface.ts","../../../src/interfaces/console/command/command.interface.ts","../../../src/interfaces/console/command/registry.interface.ts","../../../src/interfaces/console/command/collector.interface.ts","../../../src/interfaces/console/command/scheduler.interface.ts","../../../src/interfaces/console/ui/table-output.interface.ts","../../../src/interfaces/console/ui/progress-bar.interface.ts"],"names":["IInput","IOutput","IStubGenerator","IApplication","ICommand","ICommandRegistry","ICommandCollector","ICommandScheduler","ITableOutput","IProgressBar"],"mappings":";;;;;;;;;;;;;AAyDiBA;AAAA,CAAV,CAAUA,OAAV,KAAA;AAKE,EAAMA,OAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,QAAQ,CAAA;AAAA,CALjB,EAAAA,cAAA,KAAAA,cAAA,GAAA,EAAA,CAAA,CAAA;;;ACIAC;AAAA,CAAV,CAAUA,QAAV,KAAA;AAKE,EAAMA,QAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,SAAS,CAAA;AAAA,CALlB,EAAAA,eAAA,KAAAA,eAAA,GAAA,EAAA,CAAA,CAAA;;;AChCAC;AAAA,CAAV,CAAUA,eAAV,KAAA;AAKE,EAAMA,eAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,gBAAgB,CAAA;AAAA,CALzB,EAAAA,sBAAA,KAAAA,sBAAA,GAAA,EAAA,CAAA,CAAA;;;ACkBAC;AAAA,CAAV,CAAUA,aAAV,KAAA;AAKE,EAAMA,aAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,cAAc,CAAA;AAAA,CALvB,EAAAA,2BAAA,KAAAA,2BAAA,GAAA,EAAA,CAAA,CAAA;;;ACmIAC;AAAA,CAAV,CAAUA,SAAV,KAAA;AAKE,EAAMA,SAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,UAAU,CAAA;AAAA,CALnB,EAAAA,gBAAA,KAAAA,gBAAA,GAAA,EAAA,CAAA,CAAA;;;ACxHAC;AAAA,CAAV,CAAUA,iBAAV,KAAA;AAKE,EAAMA,iBAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,kBAAkB,CAAA;AAAA,CAL3B,EAAAA,wBAAA,KAAAA,wBAAA,GAAA,EAAA,CAAA,CAAA;;;ACpBAC;AAAA,CAAV,CAAUA,kBAAV,KAAA;AAKE,EAAMA,kBAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,mBAAmB,CAAA;AAAA,CAL5B,EAAAA,yBAAA,KAAAA,yBAAA,GAAA,EAAA,CAAA,CAAA;;;ACsBAC;AAAA,CAAV,CAAUA,kBAAV,KAAA;AAKE,EAAMA,kBAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,mBAAmB,CAAA;AAAA,CAL5B,EAAAA,yBAAA,KAAAA,yBAAA,GAAA,EAAA,CAAA,CAAA;;;ACpBAC;AAAA,CAAV,CAAUA,aAAV,KAAA;AAKE,EAAMA,aAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,cAAc,CAAA;AAAA,CALvB,EAAAA,oBAAA,KAAAA,oBAAA,GAAA,EAAA,CAAA,CAAA;;;ACPAC;AAAA,CAAV,CAAUA,aAAV,KAAA;AAKE,EAAMA,aAAAA,CAAA,CAAI,GAAA,MAAA,CAAO,cAAc,CAAA;AAAA,CALvB,EAAAA,oBAAA,KAAAA,oBAAA,GAAA,EAAA,CAAA,CAAA","file":"index.js","sourcesContent":["/**\n * Interface for console input\n *\n * Provides methods for accessing command line arguments and options.\n */\nexport interface IInput {\n  /**\n   * Gets the command name from the input\n   *\n   * @returns {string | undefined} The command name or undefined if not provided\n   */\n  getCommandName(): string | undefined\n\n  /**\n   * Gets an argument value by name\n   *\n   * @param {string} name - The name of the argument\n   * @returns {string | undefined} The argument value or undefined if not provided\n   */\n  getArgument(name: string): string | undefined\n\n  /**\n   * Gets all arguments\n   *\n   * @returns {Record<string, string>} Map of argument names to values\n   */\n  getArguments(): Record<string, string>\n\n  /**\n   * Gets an option value by name\n   *\n   * @param {string} name - The name of the option\n   * @returns {string | boolean | undefined} The option value or undefined if not provided\n   */\n  getOption(name: string): string | boolean | undefined\n\n  /**\n   * Gets all options\n   *\n   * @returns {Record<string, string | boolean>} Map of option names to values\n   */\n  getOptions(): Record<string, string | boolean>\n\n  /**\n   * Checks if an option is set\n   *\n   * @param {string} name - The name of the option\n   * @returns {boolean} True if the option is set, false otherwise\n   */\n  hasOption(name: string): boolean\n}\n\n/**\n * Namespace for IInput interface\n *\n * Contains token for dependency injection\n */\nexport namespace IInput {\n  /**\n   * Token for the IInput interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IInput')\n}\n","/**\n * Interface for console output\n *\n * Provides methods for writing to the console.\n */\nexport interface IOutput {\n  /**\n   * Writes a message to the output\n   *\n   * @param {string} message - The message to write\n   */\n  write(message: string): void\n\n  /**\n   * Writes a message to the output followed by a newline\n   *\n   * @param {string} message - The message to write\n   */\n  writeln(message: string): void\n\n  /**\n   * Writes an error message to the output\n   *\n   * @param {string} message - The error message to write\n   */\n  error(message: string): void\n\n  /**\n   * Writes a success message to the output\n   *\n   * @param {string} message - The success message to write\n   */\n  success(message: string): void\n\n  /**\n   * Writes an info message to the output\n   *\n   * @param {string} message - The info message to write\n   */\n  info(message: string): void\n\n  /**\n   * Writes a warning message to the output\n   *\n   * @param {string} message - The warning message to write\n   */\n  warning(message: string): void\n\n  /**\n   * Writes a comment message to the output\n   *\n   * @param {string} message - The comment message to write\n   */\n  comment(message: string): void\n}\n\n/**\n * Namespace for IOutput interface\n *\n * Contains token for dependency injection\n */\nexport namespace IOutput {\n  /**\n   * Token for the IOutput interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IOutput')\n}\n","/**\n * Interface for the stub generator\n *\n * Handles the generation of files from stub templates.\n */\nexport interface IStubGenerator {\n  /**\n   * Generates a file from a stub template\n   *\n   * @param {string} stubName - The name of the stub template\n   * @param {string} outputPath - The path where the generated file will be saved\n   * @param {Record<string, string>} replacements - Map of placeholders to their replacements\n   * @returns {boolean} True if the file was generated successfully, false otherwise\n   */\n  generate(stubName: string, outputPath: string, replacements: Record<string, string>): boolean\n\n  /**\n   * Gets the list of available stub templates\n   *\n   * @returns {string[]} Array of stub template names\n   */\n  getAvailableStubs(): string[]\n}\n\n/**\n * Namespace for IStubGenerator interface\n *\n * Contains token for dependency injection\n */\nexport namespace IStubGenerator {\n  /**\n   * Token for the IStubGenerator interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IStubGenerator')\n}\n","import type { ICommand } from './command/command.interface'\n\n/**\n * Interface for the console application\n *\n * Manages the console commands and their execution.\n */\nexport interface IApplication {\n  /**\n   * Registers a command with the application\n   *\n   * @param {ICommand} command - The command to register\n   * @returns {IApplication} - The application instance for chaining\n   */\n  register(command: ICommand): IApplication\n\n  /**\n   * Registers multiple commands with the application\n   *\n   * @param {ICommand[]} commands - The commands to register\n   * @returns {IApplication} - The application instance for chaining\n   */\n  registerCommands(commands: ICommand[]): IApplication\n\n  /**\n   * Discovers and registers commands from a directory\n   *\n   * @param {string} directory - The directory to scan for commands\n   * @param {string} pattern - The glob pattern to match command files\n   * @returns {Promise<IApplication>} - The application instance for chaining\n   */\n  discoverCommands(directory: string, pattern?: string): Promise<IApplication>\n\n  /**\n   * Runs the application with the given arguments\n   *\n   * @param {string[]} argv - The command line arguments\n   * @returns {Promise<void>}\n   */\n  run(argv?: string[]): Promise<void>\n}\n\n/**\n * Namespace for IApplication interface\n *\n * Contains token for dependency injection\n */\nexport namespace IApplication {\n  /**\n   * Token for the IApplication interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IApplication')\n}\n","import type { IInput } from '../input.interface'\nimport type { IOutput } from '../output.interface'\n\nimport { IAsk } from '../ui/ask.interface'\nimport { ITableStyle } from '../ui/table-style.interface'\nimport { IProgressBar } from '../ui/progress-bar.interface'\nimport { ITableOutput } from '../ui/table-output.interface'\nimport { IProgressBarFormat } from '../ui/progress-bar-format.interface'\n\n/**\n * Interface for console command classes.\n *\n * Defines the structure and lifecycle of a command,\n * including argument/option handling and execution hooks.\n */\nexport interface ICommand {\n  /**\n   * Gets the name of the command.\n   *\n   * @returns The command name.\n   */\n  getName(): string\n\n  /**\n   * Gets the description of the command.\n   *\n   * @returns The command description.\n   */\n  getDescription(): string\n\n  /**\n   * Sets the input instance for the command.\n   *\n   * @param input - The input instance to set.\n   */\n  setInput(input: IInput): void\n\n  /**\n   * Gets the current input instance.\n   *\n   * @returns The input instance.\n   */\n  getInput(): IInput\n\n  /**\n   * Sets the output instance for the command.\n   *\n   * @param output - The output instance to set.\n   */\n  setOutput(output: IOutput): void\n\n  /**\n   * Gets the current output instance.\n   *\n   * @returns The output instance.\n   */\n  getOutput(): IOutput\n\n  /**\n   * Sets multiple arguments by index or name.\n   *\n   * @param args - Array of positional arguments.\n   */\n  setArguments(args: string[]): void\n\n  /**\n   * Sets a single named argument.\n   *\n   * @param key - Argument key.\n   * @param value - Argument value.\n   */\n  setArgument(key: string, value: any): void\n\n  /**\n   * Gets all arguments.\n   *\n   * @returns A key-value map of arguments.\n   */\n  getArguments(): Record<string, any>\n\n  /**\n   * Retrieves a single argument by name.\n   *\n   * @param key - The argument name.\n   * @param defaultValue - default value .\n   * @returns The value of the argument or undefined if not found.\n   */\n  getArgument<T = any>(key: string, defaultValue?: T): T | undefined\n\n  /**\n   * Sets multiple options by key.\n   *\n   * @param options - Key-value map of options.\n   */\n  setOptions(options: Record<string, any>): void\n\n  /**\n   * Sets a single option.\n   *\n   * @param key - Option key.\n   * @param value - Option value.\n   */\n  setOption(key: string, value: any): void\n\n  /**\n   * Gets all options.\n   *\n   * @returns A key-value map of options.\n   */\n  getOptions(): Record<string, any>\n\n  /**\n   * Retrieves a single option by name.\n   *\n   * @param key - The option name.\n   * @param defaultValue - default value .\n   * @returns The value of the option or undefined if not found.\n   */\n  getOption<T = any>(key: string, defaultValue?: T): T | undefined\n\n  /**\n   * Allows a command to define its expected arguments and options.\n   * Called before execution.\n   */\n  configure(): void\n\n  /**\n   * Main execution logic of the command.\n   * Must return a status code (or void).\n   *\n   * @returns Promise resolving to exit code or void.\n   */\n  execute(): Promise<number | void>\n\n  /**\n   * Hook called before command execution.\n   * Return false to cancel execution.\n   *\n   * @returns Whether to continue execution.\n   */\n  beforeExecute(): Promise<boolean>\n\n  /**\n   * Hook called after command execution.\n   *\n   * @param exitCode - The result from execute().\n   */\n  afterExecute(exitCode: number | void): Promise<void>\n\n  /**\n   * Ask utility class\n   *\n   * @returns Ask utility class\n   */\n  ask(): IAsk\n\n  /**\n   * Creates a new ProgressBar instance\n   *\n   * @param {number} total - The total value\n   * @param {IProgressBarFormat} format - The format options\n   */\n  progress(total: number, format?: IProgressBarFormat): IProgressBar\n\n  /**\n   * Creates a new TableOutput instance\n   *\n   * @param {string[]} headers - The table headers\n   * @param {ITableStyle} style - The table style\n   */\n  table(headers: string[], style?: ITableStyle): ITableOutput\n}\n\n/**\n * Namespace for ICommand interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommand {\n  /**\n   * Token for the ICommand interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommand')\n}\n","import type { ICommand } from './command.interface'\n\n/**\n * Interface for the command registry\n *\n * Stores and manages all registered commands.\n */\nexport interface ICommandRegistry {\n  /**\n   * Adds a command to the registry\n   *\n   * @param {ICommand} command - The command to add\n   * @throws {Error} If a command with the same name already exists\n   */\n  add(command: ICommand): void\n\n  /**\n   * Gets a command by name\n   *\n   * @param {string} name - The name of the command\n   * @returns {ICommand | undefined} The command or undefined if not found\n   */\n  get(name: string): ICommand | undefined\n\n  /**\n   * Gets all registered commands\n   *\n   * @returns {ICommand[]} Array of all registered commands\n   */\n  getAll(): ICommand[]\n\n  /**\n   * Checks if a command exists\n   *\n   * @param {string} name - The name of the command\n   * @returns {boolean} True if the command exists, false otherwise\n   */\n  has(name: string): boolean\n\n  /**\n   * Removes a command from the registry\n   *\n   * @param {string} name - The name of the command\n   * @returns {boolean} True if the command was removed, false otherwise\n   */\n  remove(name: string): boolean\n\n  /**\n   * Clears all commands from the registry\n   */\n  clear(): void\n}\n\n/**\n * Namespace for ICommandRegistry interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandRegistry {\n  /**\n   * Token for the ICommandRegistry interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandRegistry')\n}\n","import type { ICommand } from './command.interface'\n\n/**\n * Interface for command collector\n *\n * Discovers and collects commands from the file system.\n */\nexport interface ICommandCollector {\n  /**\n   * Discovers commands in the specified directory\n   *\n   * @param {string} directory - The directory to scan for commands\n   * @param {string} pattern - The glob pattern to match command files\n   * @returns {Promise<ICommand[]>} The discovered commands\n   */\n  discoverCommands(directory: string, pattern?: string): Promise<ICommand[]>\n\n  /**\n   * Gets all commands that have been registered with the container\n   *\n   * @returns {ICommand[]} The registered commands\n   */\n  getRegisteredCommands(): ICommand[]\n\n  /**\n   * Gets command metadata for a command class\n   *\n   * @param {Function} commandClass - The command class\n   * @returns {any} The command metadata\n   */\n  getCommandMetadata(commandClass: Function): any\n}\n\n/**\n * Namespace for ICommandCollector interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandCollector {\n  /**\n   * Token for the ICommandCollector interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandCollector')\n}\n","import type { IScheduledTask } from '../schedule/task.interface'\nimport type { IScheduleExpression } from '../schedule/expression.interface'\n\n/**\n * Interface for the command scheduler\n *\n * Schedules commands to run at specific intervals.\n */\nexport interface ICommandScheduler {\n  /**\n   * Schedules a command to run at a specific interval\n   *\n   * @param {string} commandName - The name of the command\n   * @param {IScheduleExpression} expression - The schedule expression\n   * @param {string[]} args - The arguments to pass to the command\n   * @param {Record<string, any>} options - The options to pass to the command\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  schedule(\n    commandName: string,\n    expression: IScheduleExpression,\n    args?: string[],\n    options?: Record<string, any>,\n  ): ICommandScheduler\n\n  /**\n   * Starts the scheduler\n   *\n   * @param {number} interval - The interval in milliseconds to check for tasks to run\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  start(interval?: number): ICommandScheduler\n\n  /**\n   * Stops the scheduler\n   *\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  stop(): ICommandScheduler\n\n  /**\n   * Gets all scheduled tasks\n   *\n   * @returns {IScheduledTask[]} The scheduled tasks\n   */\n  getTasks(): IScheduledTask[]\n\n  /**\n   * Clears all scheduled tasks\n   *\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  clearTasks(): ICommandScheduler\n}\n\n/**\n * Namespace for ICommandScheduler interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandScheduler {\n  /**\n   * Token for the ICommandScheduler interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandScheduler')\n}\n","/**\n * Interface for table output\n *\n * Provides methods for displaying tables in the console.\n */\nexport interface ITableOutput {\n  /**\n   * Adds a row to the table\n   *\n   * @param {any[]} row - The row data\n   * @returns {ITableOutput} The table instance for chaining\n   */\n  addRow(row: any[]): ITableOutput\n\n  /**\n   * Adds multiple rows to the table\n   *\n   * @param {any[][]} rows - The rows data\n   * @returns {ITableOutput} The table instance for chaining\n   */\n  addRows(rows: any[][]): ITableOutput\n\n  /**\n   * Renders the table to a string\n   *\n   * @returns {string} The rendered table\n   */\n  toString(): string\n\n  /**\n   * Renders the table to the console\n   */\n  render(): void\n}\n\n/**\n * Namespace for ITableOutput interface\n *\n * Contains token for dependency injection\n */\nexport namespace ITableOutput {\n  /**\n   * Token for the ITableOutput interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ITableOutput')\n}\n","/**\n * Interface for progress bar\n *\n * Provides methods for displaying progress bars in the console.\n */\nexport interface IProgressBar {\n  /**\n   * Updates the progress bar\n   *\n   * @param {number} value - The current value\n   * @param {Record<string, any>} payload - Additional payload data\n   */\n  update(value: number, payload?: Record<string, any>): void\n\n  /**\n   * Increments the progress bar\n   *\n   * @param {number} value - The value to increment by\n   * @param {Record<string, any>} payload - Additional payload data\n   */\n  increment(value?: number, payload?: Record<string, any>): void\n\n  /**\n   * Stops the progress bar\n   */\n  stop(): void\n}\n\n/**\n * Namespace for IProgressBar interface\n *\n * Contains token for dependency injection\n */\nexport namespace IProgressBar {\n  /**\n   * Token for the IProgressBar interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IProgressBar')\n}\n"]}