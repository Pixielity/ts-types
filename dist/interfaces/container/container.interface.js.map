{"version":3,"sources":["../../../src/interfaces/container/container.interface.ts"],"names":["IContainer"],"mappings":";;;;;;;;;;;;;AAobiBA;AAAA,CAAV,CAAUA,WAAV,KAAA;AAIE,EAAMA,WAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,YAAY,CAAA;AAAA,CAJzB,EAAAA,kBAAA,KAAAA,kBAAA,GAAA,EAAA,CAAA,CAAA","file":"container.interface.js","sourcesContent":["import type { Container as InversifyContainer, interfaces } from 'inversify'\n\nimport type { IContextualBindingBuilder } from './contextual-binding-builder.interface'\nimport type { IServiceProvider } from '../application'\nimport { ServiceIdentifier } from '../../types'\n\n/**\n * Interface for the service container.\n */\nexport interface IContainer {\n  /**\n   * Get the underlying Inversify container.\n   *\n   * @returns The Inversify container\n   */\n  getInversifyContainer(): InversifyContainer\n\n  /**\n   * Determine if the given abstract type has been bound.\n   *\n   * @param abstract - The abstract type to check\n   * @returns True if the abstract type has been bound, false otherwise\n   */\n  has(abstract: ServiceIdentifier): boolean\n\n  /**\n   * Load container modules.\n   *\n   * @param modules - The container modules to load\n   * @returns The container instance\n   */\n  load(...modules: interfaces.ContainerModule[]): IContainer\n\n  /**\n   * Load container modules asynchronously.\n   *\n   * @param modules - The container modules to load\n   */\n  loadAsync(...modules: interfaces.AsyncContainerModule[]): Promise<IContainer>\n\n  /**\n   * Unload container modules.\n   *\n   * @param modules - The container modules to unload\n   * @returns The container instance\n   */\n  unload(...modules: interfaces.ContainerModuleBase[]): IContainer\n\n  /**\n   * Unload container modules asynchronously.\n   *\n   * @param modules - The container modules to unload\n   */\n  unloadAsync(...modules: interfaces.ContainerModuleBase[]): Promise<IContainer>\n\n  /**\n   * Register a binding with the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   * @param shared - Whether the binding should be shared\n   */\n  bind<T>(\n    abstract: string | ServiceIdentifier<T>,\n    concrete?: any,\n    shared?: boolean,\n  ): IContainer | interfaces.BindingToSyntax<T>\n\n  /**\n   * Rebind a service identifier.\n   *\n   * @param serviceIdentifier - The service identifier to rebind\n   * @returns The binding syntax\n   */\n  rebind<T>(serviceIdentifier: ServiceIdentifier<T>): interfaces.BindingToSyntax<T>\n\n  /**\n   * Rebind a service identifier asynchronously.\n   *\n   * @param serviceIdentifier - The service identifier to rebind\n   */\n  rebindAsync<T>(serviceIdentifier: ServiceIdentifier<T>): Promise<interfaces.BindingToSyntax<T>>\n\n  /**\n   * Unbind a service identifier.\n   *\n   * @param serviceIdentifier - The service identifier to unbind\n   */\n  unbind(serviceIdentifier: ServiceIdentifier<any>): void\n\n  /**\n   * Unbind a service identifier asynchronously.\n   *\n   * @param serviceIdentifier - The service identifier to unbind\n   * @returns A promise that resolves when the unbinding is complete\n   */\n  unbindAsync(serviceIdentifier: ServiceIdentifier<any>): Promise<void>\n\n  /**\n   * Unbind all bindings.\n   */\n  unbindAll(): void\n\n  /**\n   * Unbind all bindings asynchronously.\n   *\n   * @returns A promise that resolves when all unbindings are complete\n   */\n  unbindAllAsync(): Promise<void>\n\n  /**\n   * Unbind a tagged binding.\n   *\n   * @param serviceIdentifier - The service identifier\n   * @param key - The tag key\n   * @param value - The tag value\n   */\n  unbindTagged<T>(serviceIdentifier: ServiceIdentifier<T>, key: string, value: any): void\n\n  /**\n   * Register a binding with a tag.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @param shared - Whether the binding should be shared\n   */\n  bindTagged(\n    abstract: ServiceIdentifier,\n    concrete: any,\n    tag: string,\n    value: any,\n    shared?: boolean,\n  ): IContainer\n\n  /**\n   * Register a shared binding in the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   * @returns The container instance\n   */\n  singleton<T>(abstract: ServiceIdentifier<T>, concrete: any): IContainer\n\n  /**\n   * Register an existing instance as shared in the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param instance - The instance to register\n   * @returns The container instance\n   */\n  instance<T>(abstract: ServiceIdentifier<T>, instance: T): IContainer\n\n  /**\n   * Alias a type to a different name.\n   *\n   * @param abstract - The abstract type to alias\n   * @param alias - The alias identifier\n   * @returns The container instance\n   */\n  alias<T>(abstract: ServiceIdentifier<T>, alias: ServiceIdentifier<T>): IContainer\n\n  /**\n   * Apply middleware to the container.\n   *\n   * @param middlewares - The middleware to apply\n   * @returns The container instance\n   */\n  applyMiddleware(...middlewares: interfaces.Middleware[]): IContainer\n\n  /**\n   * Apply a custom metadata reader to the container.\n   *\n   * @param metadataReader - The metadata reader to apply\n   * @returns The container instance\n   */\n  applyCustomMetadataReader(metadataReader: interfaces.MetadataReader): IContainer\n\n  /**\n   * Define a contextual binding.\n   *\n   * @param concrete - The concrete implementation that needs a dependency\n   * @returns A builder for defining the contextual binding\n   */\n  when(concrete: string | Function): IContextualBindingBuilder\n\n  /**\n   * Register a contextual binding in the container.\n   *\n   * @param concrete - The concrete implementation that needs a dependency\n   * @param abstract - The abstract type that the concrete implementation needs\n   * @param tag - The tag for the binding\n   * @returns The container instance\n   * @internal\n   */\n  registerContextualBinding(concrete: string, abstract: ServiceIdentifier, tag: string): IContainer\n\n  /**\n   * Register an activation handler for a service.\n   *\n   * @param serviceIdentifier - The service identifier\n   * @param onActivation - The activation handler\n   */\n  onActivation<T>(\n    serviceIdentifier: ServiceIdentifier<T>,\n    onActivation: interfaces.BindingActivation<T>,\n  ): void\n\n  /**\n   * Register a deactivation handler for a service.\n   *\n   * @param serviceIdentifier - The service identifier\n   * @param onDeactivation - The deactivation handler\n   */\n  onDeactivation<T>(\n    serviceIdentifier: ServiceIdentifier<T>,\n    onDeactivation: interfaces.BindingDeactivation<T>,\n  ): void\n\n  /**\n   * Check if a service identifier is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @returns True if the service identifier is bound, false otherwise\n   */\n  isBound(serviceIdentifier: ServiceIdentifier<unknown>): boolean\n\n  /**\n   * Check if a service identifier is bound in the current container (not in ancestors).\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @returns True if the service identifier is bound in the current container, false otherwise\n   */\n  isCurrentBound<T>(serviceIdentifier: ServiceIdentifier<T>): boolean\n\n  /**\n   * Check if a named binding is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @param named - The name to check\n   * @returns True if the named binding is bound, false otherwise\n   */\n  isBoundNamed(serviceIdentifier: ServiceIdentifier<any>, named: string | number | symbol): boolean\n\n  /**\n   * Check if a tagged binding is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @param key - The tag key\n   * @param value - The tag value\n   * @returns True if the tagged binding is bound, false otherwise\n   */\n  isBoundTagged(\n    serviceIdentifier: ServiceIdentifier<any>,\n    key: string | number | symbol,\n    value: unknown,\n  ): boolean\n\n  /**\n   * Create a snapshot of the container's state.\n   */\n  snapshot(): void\n\n  /**\n   * Restore the container's state from a snapshot.\n   */\n  restore(): void\n\n  /**\n   * Create a child container.\n   *\n   * @param containerOptions - The container options\n   * @returns A new child container\n   */\n  createChild(containerOptions?: interfaces.ContainerOptions): IContainer\n\n  /**\n   * Resolve the given type from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param parameters - Optional parameters to pass to the constructor\n   */\n  make<T>(abstract: ServiceIdentifier<T>, parameters?: any[]): T\n\n  /**\n   * Resolve the given type from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @returns A promise that resolves to the resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeAsync<T>(abstract: ServiceIdentifier<T>): Promise<T>\n\n  /**\n   * Resolve a tagged binding from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @returns The resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeTagged<T>(abstract: ServiceIdentifier<T>, tag: string, value: any): T\n\n  /**\n   * Resolve a tagged binding from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @returns A promise that resolves to the resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeTaggedAsync<T>(abstract: ServiceIdentifier<T>, tag: string, value: any): Promise<T>\n\n  /**\n   * Resolve a named binding from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   * @returns The resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeNamed<T>(abstract: ServiceIdentifier<T>, named: string | number | symbol): T\n\n  /**\n   * Resolve a named binding from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   * @returns A promise that resolves to the resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeNamedAsync<T>(abstract: ServiceIdentifier<T>, named: string | number | symbol): Promise<T>\n\n  /**\n   * Resolve all bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   * @returns All resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAll<T>(abstract: ServiceIdentifier<T>): T[]\n\n  /**\n   * Resolve all bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @returns A promise that resolves to all resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllAsync<T>(abstract: ServiceIdentifier<T>): Promise<T[]>\n\n  /**\n   * Resolve all tagged bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @returns All resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllTagged<T>(abstract: ServiceIdentifier<T>, tag: string, value: any): T[]\n\n  /**\n   * Resolve all tagged bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @returns A promise that resolves to all resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllTaggedAsync<T>(abstract: ServiceIdentifier<T>, tag: string, value: any): Promise<T[]>\n\n  /**\n   * Resolve all named bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   * @returns All resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllNamed<T>(abstract: ServiceIdentifier<T>, named: string | number | symbol): T[]\n\n  /**\n   * Resolve all named bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   * @returns A promise that resolves to all resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllNamedAsync<T>(\n    abstract: ServiceIdentifier<T>,\n    named: string | number | symbol,\n  ): Promise<T[]>\n\n  /**\n   * Resolve a class constructor.\n   *\n   * @param constructorFunction - The constructor function to resolve\n   * @returns The resolved instance\n   * @template T - The type of the resolved instance\n   */\n  resolve<T>(constructorFunction: interfaces.Newable<T>): T\n\n  /**\n   * Register a service provider with the container.\n   *\n   * @param provider - The service provider to register\n   * @returns The container instance\n   */\n  register(provider: IServiceProvider): IContainer\n\n  /**\n   * Boot the registered service providers.\n   *\n   * @returns The container instance\n   */\n  boot(): IContainer\n\n  /**\n   * Call the given callback with the container instance.\n   *\n   * @param callback - The callback to call\n   * @returns The result of the callback\n   * @template T - The return type of the callback\n   */\n  call<T>(callback: (container: IContainer) => T): T\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IContainer {\n  /**\n   * Symbol for injecting the container service\n   */\n  export const $ = Symbol.for('IContainer')\n}\n"]}