{"version":3,"sources":["../../../src/interfaces/container/container.interface.ts"],"names":["IContainer"],"mappings":";;;;;;;;;;;;;AAoWiBA;AAAA,CAAV,CAAUA,WAAV,KAAA;AAIE,EAAMA,WAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,YAAY,CAAA;AAAA,CAJzB,EAAAA,kBAAA,KAAAA,kBAAA,GAAA,EAAA,CAAA,CAAA","file":"index.js","sourcesContent":["import type { Container as InversifyContainer, interfaces } from \"inversify\"\nimport type { IContextualBindingBuilder } from \"./contextual-binding-builder.interface\"\nimport type { IServiceProvider } from \"../application\"\n\n/**\n * Interface for the service container.\n */\nexport interface IContainer {\n  /**\n   * Get the underlying Inversify container.\n   */\n  getInversifyContainer(): InversifyContainer\n\n  /**\n   * Determine if the given abstract type has been bound.\n   *\n   * @param abstract - The abstract type to check\n   */\n  has(abstract: string): boolean\n\n  /**\n   * Load container modules.\n   *\n   * @param modules - The container modules to load\n   */\n  load(...modules: interfaces.ContainerModule[]): IContainer\n\n  /**\n   * Load container modules asynchronously.\n   *\n   * @param modules - The container modules to load\n   */\n  loadAsync(...modules: interfaces.AsyncContainerModule[]): Promise<IContainer>\n\n  /**\n   * Unload container modules.\n   *\n   * @param modules - The container modules to unload\n   */\n  unload(...modules: interfaces.ContainerModuleBase[]): IContainer\n\n  /**\n   * Unload container modules asynchronously.\n   *\n   * @param modules - The container modules to unload\n   */\n  unloadAsync(...modules: interfaces.ContainerModuleBase[]): Promise<IContainer>\n\n  /**\n   * Register a binding with the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   * @param shared - Whether the binding should be shared\n   */\n  bind<T>(\n    abstract: string | interfaces.ServiceIdentifier<T>,\n    concrete?: any,\n    shared?: boolean,\n  ): IContainer | interfaces.BindingToSyntax<T>\n\n  /**\n   * Rebind a service identifier.\n   *\n   * @param serviceIdentifier - The service identifier to rebind\n   */\n  rebind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T>\n\n  /**\n   * Rebind a service identifier asynchronously.\n   *\n   * @param serviceIdentifier - The service identifier to rebind\n   */\n  rebindAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): Promise<interfaces.BindingToSyntax<T>>\n\n  /**\n   * Unbind a service identifier.\n   *\n   * @param serviceIdentifier - The service identifier to unbind\n   */\n  unbind(serviceIdentifier: interfaces.ServiceIdentifier<any>): void\n\n  /**\n   * Unbind a service identifier asynchronously.\n   *\n   * @param serviceIdentifier - The service identifier to unbind\n   */\n  unbindAsync(serviceIdentifier: interfaces.ServiceIdentifier<any>): Promise<void>\n\n  /**\n   * Unbind all bindings.\n   */\n  unbindAll(): void\n\n  /**\n   * Unbind all bindings asynchronously.\n   */\n  unbindAllAsync(): Promise<void>\n\n  /**\n   * Register a binding with a tag.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @param shared - Whether the binding should be shared\n   */\n  bindTagged(abstract: string, concrete: any, tag: string, value: any, shared?: boolean): IContainer\n\n  /**\n   * Register a shared binding in the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   */\n  singleton(abstract: string, concrete: any): IContainer\n\n  /**\n   * Register an existing instance as shared in the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param instance - The instance to register\n   */\n  instance(abstract: string, instance: any): IContainer\n\n  /**\n   * Alias a type to a different name.\n   *\n   * @param abstract - The abstract type to alias\n   * @param alias - The alias name\n   */\n  alias(abstract: string, alias: string): IContainer\n\n  /**\n   * Apply middleware to the container.\n   *\n   * @param middlewares - The middleware to apply\n   */\n  applyMiddleware(...middlewares: interfaces.Middleware[]): IContainer\n\n  /**\n   * Apply a custom metadata reader to the container.\n   *\n   * @param metadataReader - The metadata reader to apply\n   */\n  applyCustomMetadataReader(metadataReader: interfaces.MetadataReader): IContainer\n\n  /**\n   * Define a contextual binding.\n   *\n   * @param concrete - The concrete implementation that needs a dependency\n   */\n  when(concrete: string | Function): IContextualBindingBuilder\n\n  /**\n   * Register an activation handler for a service.\n   *\n   * @param serviceIdentifier - The service identifier\n   * @param onActivation - The activation handler\n   */\n  onActivation<T>(\n    serviceIdentifier: interfaces.ServiceIdentifier<T>,\n    onActivation: interfaces.BindingActivation<T>,\n  ): void\n\n  /**\n   * Register a deactivation handler for a service.\n   *\n   * @param serviceIdentifier - The service identifier\n   * @param onDeactivation - The deactivation handler\n   */\n  onDeactivation<T>(\n    serviceIdentifier: interfaces.ServiceIdentifier<T>,\n    onDeactivation: interfaces.BindingDeactivation<T>,\n  ): void\n\n  /**\n   * Check if a service identifier is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   */\n  isBound(serviceIdentifier: interfaces.ServiceIdentifier<unknown>): boolean\n\n  /**\n   * Check if a service identifier is bound in the current container (not in ancestors).\n   *\n   * @param serviceIdentifier - The service identifier to check\n   */\n  isCurrentBound<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): boolean\n\n  /**\n   * Check if a named binding is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @param named - The name to check\n   */\n  isBoundNamed(serviceIdentifier: interfaces.ServiceIdentifier<any>, named: string | number | symbol): boolean\n\n  /**\n   * Check if a tagged binding is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @param key - The tag key\n   * @param value - The tag value\n   */\n  isBoundTagged(\n    serviceIdentifier: interfaces.ServiceIdentifier<any>,\n    key: string | number | symbol,\n    value: unknown,\n  ): boolean\n\n  /**\n   * Create a snapshot of the container's state.\n   */\n  snapshot(): void\n\n  /**\n   * Restore the container's state from a snapshot.\n   */\n  restore(): void\n\n  /**\n   * Create a child container.\n   *\n   * @param containerOptions - The container options\n   */\n  createChild(containerOptions?: interfaces.ContainerOptions): IContainer\n\n  /**\n   * Resolve the given type from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param parameters - Optional parameters to pass to the constructor\n   */\n  make<T>(abstract: string, parameters?: any[]): T\n\n  /**\n   * Resolve the given type from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   */\n  makeAsync<T>(abstract: string): Promise<T>\n\n  /**\n   * Resolve a tagged binding from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   */\n  makeTagged<T>(abstract: string, tag: string, value: any): T\n\n  /**\n   * Resolve a tagged binding from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   */\n  makeTaggedAsync<T>(abstract: string, tag: string, value: any): Promise<T>\n\n  /**\n   * Resolve a named binding from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   */\n  makeNamed<T>(abstract: string, named: string | number | symbol): T\n\n  /**\n   * Resolve a named binding from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   */\n  makeNamedAsync<T>(abstract: string, named: string | number | symbol): Promise<T>\n\n  /**\n   * Resolve all bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   */\n  makeAll<T>(abstract: string): T[]\n\n  /**\n   * Resolve all bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   */\n  makeAllAsync<T>(abstract: string): Promise<T[]>\n\n  /**\n   * Resolve all tagged bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   */\n  makeAllTagged<T>(abstract: string, tag: string, value: any): T[]\n\n  /**\n   * Resolve all tagged bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   */\n  makeAllTaggedAsync<T>(abstract: string, tag: string, value: any): Promise<T[]>\n\n  /**\n   * Resolve all named bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   */\n  makeAllNamed<T>(abstract: string, named: string | number | symbol): T[]\n\n  /**\n   * Resolve all named bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   */\n  makeAllNamedAsync<T>(abstract: string, named: string | number | symbol): Promise<T[]>\n\n  /**\n   * Resolve a class constructor.\n   *\n   * @param constructorFunction - The constructor function to resolve\n   */\n  resolve<T>(constructorFunction: interfaces.Newable<T>): T\n\n  /**\n   * Register a service provider with the container.\n   *\n   * @param provider - The service provider to register\n   */\n  register(provider: IServiceProvider): IContainer\n\n  /**\n   * Boot the registered service providers.\n   */\n  boot(): IContainer\n\n  /**\n   * Call the given callback with the container instance.\n   *\n   * @param callback - The callback to call\n   */\n  call<T>(callback: (container: IContainer) => T): T\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IContainer {\n  /**\n   * Symbol for injecting the container service\n   */\n  export const $ = Symbol.for(\"IContainer\")\n}\n"]}