{"version":3,"sources":["../../../src/interfaces/cache/cache.interface.ts","../../../src/interfaces/cache/store.interface.ts","../../../src/interfaces/cache/repository.interface.ts","../../../src/interfaces/cache/tagged-cache.interface.ts","../../../src/interfaces/cache/lock.interface.ts","../../../src/interfaces/cache/lock-provider.interface.ts","../../../src/interfaces/cache/cache-manager.interface.ts"],"names":["ICache","IStore","IRepository","ITaggedCache","ILock","ILockProvider","ICacheManager"],"mappings":";;;;;;;;;;;;;AA+HiBA;AAAA,CAAV,CAAUA,OAAV,KAAA;AAIE,EAAMA,OAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,QAAQ,CAAA;AAAA,CAJrB,EAAAA,cAAA,KAAAA,cAAA,GAAA,EAAA,CAAA,CAAA;;;AC/BAC;AAAA,CAAV,CAAUA,OAAV,KAAA;AAIE,EAAMA,OAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,QAAQ,CAAA;AAK7B,EAAMA,OAAA,CAAA,UAAA,GAAa,MAAO,CAAA,GAAA,CAAI,YAAY,CAAA;AAK1C,EAAMA,OAAA,CAAA,SAAA,GAAY,MAAO,CAAA,GAAA,CAAI,WAAW,CAAA;AAKxC,EAAMA,OAAA,CAAA,cAAA,GAAiB,MAAO,CAAA,GAAA,CAAI,gBAAgB,CAAA;AAKlD,EAAMA,OAAA,CAAA,UAAA,GAAa,MAAO,CAAA,GAAA,CAAI,YAAY,CAAA;AAK1C,EAAMA,OAAA,CAAA,aAAA,GAAgB,MAAO,CAAA,GAAA,CAAI,eAAe,CAAA;AAKhD,EAAMA,OAAA,CAAA,aAAA,GAAgB,MAAO,CAAA,GAAA,CAAI,eAAe,CAAA;AAKhD,EAAMA,OAAA,CAAA,SAAA,GAAY,MAAO,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA,CAvChC,EAAAA,cAAA,KAAAA,cAAA,GAAA,EAAA,CAAA,CAAA;;;AClEAC;AAAA,CAAV,CAAUA,YAAV,KAAA;AAIE,EAAMA,YAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,aAAa,CAAA;AAAA,CAJ1B,EAAAA,mBAAA,KAAAA,mBAAA,GAAA,EAAA,CAAA,CAAA;;;ACFAC;AAAA,CAAV,CAAUA,aAAV,KAAA;AAIE,EAAMA,aAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,cAAc,CAAA;AAAA,CAJ3B,EAAAA,oBAAA,KAAAA,oBAAA,GAAA,EAAA,CAAA,CAAA;;;AC6BAC;AAAA,CAAV,CAAUA,MAAV,KAAA;AAIE,EAAMA,MAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,OAAO,CAAA;AAAA,CAJpB,EAAAA,aAAA,KAAAA,aAAA,GAAA,EAAA,CAAA,CAAA;;;ACxBAC;AAAA,CAAV,CAAUA,cAAV,KAAA;AAIE,EAAMA,cAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,eAAe,CAAA;AAAA,CAJ5B,EAAAA,qBAAA,KAAAA,qBAAA,GAAA,EAAA,CAAA,CAAA;;;AC2BAC;AAAA,CAAV,CAAUA,cAAV,KAAA;AAIE,EAAMA,cAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,eAAe,CAAA;AAAA,CAJ5B,EAAAA,qBAAA,KAAAA,qBAAA,GAAA,EAAA,CAAA,CAAA","file":"index.js","sourcesContent":["import type { ILock } from './lock.interface'\n\n/**\n * Interface for the main cache service\n * Provides methods for storing, retrieving, and managing cached data\n */\nexport interface ICache {\n  /**\n   * Get a value from the cache\n   * @param key - The cache key\n   * @param defaultValue - Default value or callback to return if key doesn't exist\n   * @returns The cached value, the default value, or undefined if not found\n   * @template T - The type of value to return\n   */\n  get<T>(key: string, defaultValue?: T): Promise<T | undefined>\n\n  /**\n   * Store a value in the cache\n   * @param key - The cache key\n   * @param value - The value to store\n   * @param ttl - Time to live in seconds (defaults to 60 if not specified)\n   * @returns True if the value was stored successfully\n   * @template T - The type of value being stored\n   */\n  put<T>(key: string, value: T, ttl?: number): Promise<boolean>\n\n  /**\n   * Store a value in the cache indefinitely\n   * @param key - The cache key\n   * @param value - The value to store\n   * @returns True if the value was stored successfully\n   * @template T - The type of value being stored\n   */\n  forever<T>(key: string, value: T): Promise<boolean>\n\n  /**\n   * Remove a value from the cache\n   * @param key - The cache key\n   * @returns True if the value was removed successfully\n   */\n  forget(key: string): Promise<boolean>\n\n  /**\n   * Remove all items from the cache\n   * @returns True if the cache was cleared successfully\n   */\n  flush(): Promise<boolean>\n\n  /**\n   * Get an item from the cache, or store the default value\n   * @param key - The cache key\n   * @param ttl - Time to live in seconds\n   * @param callback - Function that returns the default value\n   * @returns The cached value or the computed default value\n   * @template T - The type of value to return\n   */\n  remember<T>(key: string, ttl: number, callback: () => Promise<T> | T): Promise<T>\n\n  /**\n   * Get an item from the cache, or store the default value forever\n   * @param key - The cache key\n   * @param callback - Function that returns the default value\n   * @returns The cached value or the computed default value\n   * @template T - The type of value to return\n   */\n  rememberForever<T>(key: string, callback: () => Promise<T> | T): Promise<T>\n\n  /**\n   * Increment a value in the cache\n   * @param key - The cache key\n   * @param value - The value to increment by (defaults to 1)\n   * @returns The new value or false if the operation failed\n   */\n  increment(key: string, value?: number): Promise<number | boolean>\n\n  /**\n   * Decrement a value in the cache\n   * @param key - The cache key\n   * @param value - The value to decrement by (defaults to 1)\n   * @returns The new value or false if the operation failed\n   */\n  decrement(key: string, value?: number): Promise<number | boolean>\n\n  /**\n   * Get a lock instance\n   * @param name - The lock name\n   * @param seconds - The lock timeout in seconds (defaults to 60)\n   * @param owner - The lock owner (generated if not provided)\n   * @returns A lock instance\n   */\n  lock(name: string, seconds?: number, owner?: string): ILock\n\n  /**\n   * Get a lock instance without blocking\n   * @param name - The lock name\n   * @param owner - The lock owner\n   * @returns A lock instance\n   */\n  restoreLock(name: string, owner: string): ILock\n\n  /**\n   * Get multiple items from the cache\n   * @param keys - The cache keys\n   * @returns An object mapping keys to values\n   * @template T - The type of values to return\n   */\n  many<T>(keys: string[]): Promise<Record<string, T>>\n\n  /**\n   * Store multiple items in the cache\n   * @param values - The key-value pairs to store\n   * @param ttl - Time to live in seconds (defaults to 60)\n   * @returns True if the values were stored successfully\n   * @template T - The type of values being stored\n   */\n  putMany<T>(values: Record<string, T>, ttl?: number): Promise<boolean>\n\n  /**\n   * Get the cache key prefix\n   * @returns The cache key prefix\n   */\n  getPrefix(): string\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ICache {\n  /**\n   * Symbol for injecting the cache service\n   */\n  export const $ = Symbol.for('ICache')\n}\n","/**\n * Interface for cache store implementations\n * Defines the contract that all cache storage drivers must implement\n */\nimport type { ILockProvider } from './lock-provider.interface'\n\nexport interface IStore {\n  /**\n   * Retrieve an item from the cache by key\n   * @param key - The cache key\n   * @returns The cached value or undefined if not found\n   * @template T - The type of value to return\n   */\n  get<T>(key: string): Promise<T | undefined>\n\n  /**\n   * Store an item in the cache for a given number of seconds\n   * @param key - The cache key\n   * @param value - The value to store\n   * @param seconds - The time to live in seconds (defaults to 60)\n   * @returns True if the value was stored successfully\n   * @template T - The type of value being stored\n   */\n  put<T>(key: string, value: T, seconds?: number): Promise<boolean>\n\n  /**\n   * Store an item in the cache indefinitely\n   * @param key - The cache key\n   * @param value - The value to store\n   * @returns True if the value was stored successfully\n   * @template T - The type of value being stored\n   */\n  forever<T>(key: string, value: T): Promise<boolean>\n\n  /**\n   * Remove an item from the cache\n   * @param key - The cache key\n   * @returns True if the value was removed successfully\n   */\n  forget(key: string): Promise<boolean>\n\n  /**\n   * Remove all items from the cache\n   * @returns True if the cache was cleared successfully\n   */\n  flush(): Promise<boolean>\n\n  /**\n   * Get the cache key prefix\n   * @returns The cache key prefix\n   */\n  getPrefix(): string\n\n  /**\n   * Get multiple items from the cache\n   * @param keys - The cache keys\n   * @returns An object mapping keys to values\n   * @template T - The type of values to return\n   */\n  many<T>(keys: string[]): Promise<Record<string, T>>\n\n  /**\n   * Store multiple items in the cache\n   * @param values - The key-value pairs to store\n   * @param seconds - The time to live in seconds (defaults to 60)\n   * @returns True if the values were stored successfully\n   * @template T - The type of values being stored\n   */\n  putMany<T>(values: Record<string, T>, seconds?: number): Promise<boolean>\n\n  /**\n   * Increment the value of an item in the cache\n   * @param key - The cache key\n   * @param value - The value to increment by (defaults to 1)\n   * @returns The new value or false if the operation failed\n   */\n  increment(key: string, value?: number): Promise<number | boolean>\n\n  /**\n   * Decrement the value of an item in the cache\n   * @param key - The cache key\n   * @param value - The value to decrement by (defaults to 1)\n   * @returns The new value or false if the operation failed\n   */\n  decrement(key: string, value?: number): Promise<number | boolean>\n\n  /**\n   * Get the lock provider\n   * @returns The lock provider instance\n   */\n  getLockProvider(): ILockProvider\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IStore {\n  /**\n   * Symbol for injecting the store service\n   */\n  export const $ = Symbol.for('IStore')\n\n  /**\n   * Symbol for injecting the array store\n   */\n  export const ArrayStore = Symbol.for('ArrayStore')\n\n  /**\n   * Symbol for injecting the file store\n   */\n  export const FileStore = Symbol.for('FileStore')\n\n  /**\n   * Symbol for injecting the memcached store\n   */\n  export const MemcachedStore = Symbol.for('MemcachedStore')\n\n  /**\n   * Symbol for injecting the redis store\n   */\n  export const RedisStore = Symbol.for('RedisStore')\n\n  /**\n   * Symbol for injecting the dynamodb store\n   */\n  export const DynamoDbStore = Symbol.for('DynamoDbStore')\n\n  /**\n   * Symbol for injecting the database store\n   */\n  export const DatabaseStore = Symbol.for('DatabaseStore')\n\n  /**\n   * Symbol for injecting the null store\n   */\n  export const NullStore = Symbol.for('NullStore')\n}\n","import type { ICache } from './cache.interface'\nimport type { ITaggedCache } from './tagged-cache.interface'\n\n/**\n * Interface for the cache repository\n * Extends the ICache interface with tagging capabilities\n * The repository acts as a higher-level abstraction over the cache store\n */\nexport interface IRepository extends ICache {\n  /**\n   * Get a tagged cache instance\n   * Tagged caches allow grouping cache items and invalidating them together\n   *\n   * @param tags - The cache tags (single tag or array of tags)\n   * @returns A tagged cache instance\n   */\n  tags(tags: string | string[]): ITaggedCache\n\n  /**\n   * Get the underlying cache store\n   * Provides access to the store implementation for advanced operations\n   *\n   * @returns The cache store implementation\n   */\n  getStore(): any\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IRepository {\n  /**\n   * Symbol for injecting the repository service\n   */\n  export const $ = Symbol.for('IRepository')\n}\n","import type { ICache } from './cache.interface'\n\n/**\n * Interface for tagged cache\n * Tagged caches allow grouping cache items and invalidating them together\n * This is useful for cache invalidation strategies where multiple related\n * cache entries need to be invalidated at once\n */\nexport interface ITaggedCache extends ICache {\n  /**\n   * Get the tag names\n   * Returns the array of tags associated with this cache instance\n   *\n   * @returns The array of tag names\n   */\n  getTags(): string[]\n\n  /**\n   * Reset all tags\n   * This generates new tag IDs for all tags, effectively invalidating\n   * all cache entries associated with these tags\n   */\n  resetTags(): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ITaggedCache {\n  /**\n   * Symbol for injecting the tagged cache service\n   */\n  export const $ = Symbol.for('ITaggedCache')\n}\n","/**\n * Interface for cache locks\n * Provides methods for distributed locking to coordinate access to shared resources\n */\nexport interface ILock {\n  /**\n   * Attempt to acquire the lock\n   * If the lock is acquired, the callback is executed and the lock is released afterward\n   * If the lock cannot be acquired, an error is thrown\n   *\n   * @param callback - The callback to execute if the lock is acquired\n   * @returns The result of the callback\n   * @template T - The type of value returned by the callback\n   * @throws Error if the lock cannot be acquired\n   */\n  get<T>(callback: () => Promise<T> | T): Promise<T>\n\n  /**\n   * Attempt to acquire the lock for the given number of seconds\n   * This method will retry acquiring the lock until the timeout is reached\n   *\n   * @param seconds - The maximum time to wait for the lock in seconds\n   * @param callback - The callback to execute if the lock is acquired\n   * @returns The result of the callback\n   * @template T - The type of value returned by the callback\n   * @throws Error if the lock cannot be acquired within the timeout\n   */\n  block<T>(seconds: number, callback: () => Promise<T> | T): Promise<T>\n\n  /**\n   * Release the lock\n   * This will only succeed if the current instance is the owner of the lock\n   *\n   * @returns True if the lock was released successfully\n   */\n  release(): Promise<boolean>\n\n  /**\n   * Returns the owner value written to the driver for this lock\n   * The owner is a unique identifier for the lock instance\n   *\n   * @returns The lock owner string\n   */\n  owner(): string\n\n  /**\n   * Releases this lock in disregard of ownership\n   * This is a forceful operation that should be used with caution\n   *\n   * @returns True if the lock was released successfully\n   */\n  forceRelease(): Promise<boolean>\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ILock {\n  /**\n   * Symbol for injecting the lock service\n   */\n  export const $ = Symbol.for('ILock')\n}\n","import type { ILock } from './lock.interface'\n\n/**\n * Interface for lock providers\n * Lock providers are responsible for creating lock instances\n * Each cache store has its own lock provider implementation\n */\nexport interface ILockProvider {\n  /**\n   * Get a lock instance\n   * Creates a new lock with the specified name, timeout, and owner\n   *\n   * @param name - The lock name (unique identifier for the resource being locked)\n   * @param seconds - The lock timeout in seconds (defaults to 60)\n   * @param owner - The lock owner (generated if not provided)\n   * @returns A lock instance\n   */\n  lock(name: string, seconds?: number, owner?: string): ILock\n\n  /**\n   * Restore a lock instance\n   * Creates a lock instance with a specific owner, used to manage an existing lock\n   *\n   * @param name - The lock name\n   * @param owner - The lock owner\n   * @returns A lock instance\n   */\n  restoreLock(name: string, owner: string): ILock\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ILockProvider {\n  /**\n   * Symbol for injecting the lock provider service\n   */\n  export const $ = Symbol.for('ILockProvider')\n}\n","import type { IStore } from './store.interface'\nimport type { IRepository } from './repository.interface'\n\n/**\n * Interface for the cache manager\n * The cache manager is responsible for creating and managing cache stores\n * It acts as a factory for cache repositories\n */\nexport interface ICacheManager {\n  /**\n   * Get the default cache store name\n   * @returns The name of the default cache store\n   */\n  getDefaultInstance(): string\n\n  /**\n   * Set the default cache store name\n   * @param name - The store name to set as default\n   */\n  setDefaultInstance(name: string): void\n\n  /**\n   * Get the cache store configuration\n   * @param name - The store name\n   * @returns The store configuration object, or null if not found\n   */\n  getInstanceConfig(name: string): Record<string, any> | null\n\n  /**\n   * Create a new cache repository with the given implementation\n   * @param store - The cache store implementation\n   * @returns A repository instance wrapping the store\n   */\n  repository(store: IStore): IRepository\n\n  /**\n   * Get a cache store instance\n   * @param name - The store name (optional, uses default if not provided)\n   * @returns A repository instance for the requested store\n   */\n  store(name?: string): IRepository\n\n  /**\n   * Get the default cache driver name\n   * This is an alias for getDefaultInstance for compatibility with Laravel-style managers\n   * @returns The name of the default cache store\n   */\n  getDefaultDriver(): string\n\n  /**\n   * Set the default cache driver name\n   * This is an alias for setDefaultInstance for compatibility with Laravel-style managers\n   * @param name - The driver name to set as default\n   */\n  setDefaultDriver(name: string): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ICacheManager {\n  /**\n   * Symbol for injecting the cache manager service\n   */\n  export const $ = Symbol.for('ICacheManager')\n}\n"]}