{"version":3,"sources":["../../../src/interfaces/events/event.interface.ts","../../../src/interfaces/events/listener.interface.ts","../../../src/interfaces/events/event-bus.interface.ts","../../../src/interfaces/events/dispatcher.interface.ts","../../../src/interfaces/events/subscriber.interface.ts"],"names":["IEvent","IListener","IEventBus","IEventDispatcher","ISubscriber"],"mappings":";;;;;;;;;;;;;AAkCiBA;AAAA,CAAV,CAAUA,OAAV,KAAA;AACE,EAAMA,OAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,QAAQ,CAAA;AAAA,CADrB,EAAAA,cAAA,KAAAA,cAAA,GAAA,EAAA,CAAA,CAAA;;;ACdAC;AAAA,CAAV,CAAUA,UAAV,KAAA;AACE,EAAMA,UAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA,CADxB,EAAAA,iBAAA,KAAAA,iBAAA,GAAA,EAAA,CAAA,CAAA;;;AC8DAC;AAAA,CAAV,CAAUA,UAAV,KAAA;AACE,EAAMA,UAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,WAAW,CAAA;AAAA,CADxB,EAAAA,iBAAA,KAAAA,iBAAA,GAAA,EAAA,CAAA,CAAA;;;ACkCAC;AAAA,CAAV,CAAUA,iBAAV,KAAA;AACE,EAAMA,iBAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,kBAAkB,CAAA;AAAA,CAD/B,EAAAA,wBAAA,KAAAA,wBAAA,GAAA,EAAA,CAAA,CAAA;;;ACjGAC;AAAA,CAAV,CAAUA,YAAV,KAAA;AACE,EAAMA,YAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,aAAa,CAAA;AAAA,CAD1B,EAAAA,mBAAA,KAAAA,mBAAA,GAAA,EAAA,CAAA,CAAA","file":"index.js","sourcesContent":["/**\n * Interface for all events in the system.\n * Events are objects that represent something that has happened in the application.\n * They can be dispatched and listened to by event listeners.\n */\nexport interface IEvent {\n  /**\n   * Optional method to get the event name.\n   * If not provided, the class name will be used.\n   */\n  getEventName?(): string\n\n  /**\n   * Optional method to determine if the event should be broadcast.\n   * @returns {boolean} Whether the event should be broadcast\n   */\n  shouldBroadcast?(): boolean\n\n  /**\n   * Optional method to get the channels the event should broadcast on.\n   * @returns {string[]} Array of channel names\n   */\n  broadcastOn?(): string[]\n\n  /**\n   * Optional method to get the broadcast data.\n   * @returns {Record<string, any>} Data to broadcast\n   */\n  broadcastWith?(): Record<string, any>\n}\n\n/**\n * DI token for IEvent interface\n */\nexport namespace IEvent {\n  export const $ = Symbol.for('IEvent')\n}\n","import type { IEvent } from './event.interface'\n\n/**\n * Interface for all event listeners in the system.\n * Listeners are responsible for handling events when they are dispatched.\n */\nexport interface IListener<E extends IEvent = IEvent> {\n  /**\n   * Handle the event.\n   * This method is called when the event is dispatched.\n   *\n   * @param {E} event - The event object\n   * @returns {Promise<void> | void} - May return a promise for async handling\n   */\n  handle(event: E): Promise<void> | void\n}\n\n/**\n * DI token for IListener interface\n */\nexport namespace IListener {\n  export const $ = Symbol.for('IListener')\n}\n","import type { Observable } from 'rxjs'\nimport type { IEvent } from './event.interface'\nimport type { IEventData } from './event-data.interface'\n\n/**\n * Interface for the event bus\n * The event bus provides a centralized mechanism for dispatching and subscribing to events\n */\nexport interface IEventBus {\n  /**\n   * Get an observable of all events\n   *\n   * @returns An observable of all events\n   */\n  events(): Observable<IEventData>\n\n  /**\n   * Get an observable of events with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of events with the specified name\n   */\n  ofType(eventName: string): Observable<IEventData>\n\n  /**\n   * Get an observable of events of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of events of the specified class\n   */\n  ofClass<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<IEventData<T>>\n\n  /**\n   * Get an observable of event payloads with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of event payloads with the specified name\n   */\n  on<T = any>(eventName: string): Observable<T>\n\n  /**\n   * Get an observable of event payloads of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of event payloads of the specified class\n   */\n  onEvent<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<T>\n\n  /**\n   * Dispatch an event through the event bus\n   *\n   * @param event - The event to dispatch\n   * @param payload - Optional payload if event is a string\n   * @returns A promise that resolves when the event has been dispatched\n   */\n  dispatch(event: string | IEvent, payload?: any): Promise<any[]>\n\n  /**\n   * Register a callback for a specific event\n   *\n   * @param eventName - The event name\n   * @param callback - The callback function\n   * @returns A function to unregister the callback\n   */\n  subscribe<T = any>(eventName: string, callback: (data: T) => void): () => void\n\n  /**\n   * Register a callback for a specific event class\n   *\n   * @param eventClass - The event class\n   * @param callback - The callback function\n   * @returns A function to unregister the callback\n   */\n  subscribeToEvent<T extends IEvent>(\n    eventClass: new (...args: any[]) => T,\n    callback: (event: T) => void,\n  ): () => void\n}\n\n/**\n * DI token for IEventBus interface\n */\nexport namespace IEventBus {\n  export const $ = Symbol.for('IEventBus')\n}\n","import type { Observable } from 'rxjs'\nimport type { IEvent } from './event.interface'\nimport type { IListener } from './listener.interface'\nimport type { ISubscriber } from './subscriber.interface'\nimport type { IEventData } from './event-data.interface'\n\n/**\n * Interface for the event dispatcher.\n * The dispatcher is responsible for registering listeners and dispatching events.\n */\nexport interface IEventDispatcher {\n  /**\n   * Register an event listener with the dispatcher.\n   *\n   * @param {string} event - The event name\n   * @param {IListener | Function} listener - The listener function or object\n   * @returns {() => void} A function to remove the listener\n   */\n  listen(event: string, listener: IListener | Function): () => void\n\n  /**\n   * Determine if a given event has listeners.\n   *\n   * @param {string} eventName - The event name\n   * @returns {boolean} True if the event has listeners\n   */\n  hasListeners(eventName: string): boolean\n\n  /**\n   * Register an event subscriber with the dispatcher.\n   *\n   * @param {ISubscriber} subscriber - The subscriber to register\n   */\n  subscribe(subscriber: ISubscriber): void\n\n  /**\n   * Dispatch an event and call the listeners.\n   *\n   * @param {string | IEvent} event - The event name or object\n   * @param {any} [payload] - The event payload (if event is a string)\n   * @returns {Promise<any[]>} Array of results from the listeners\n   */\n  dispatch(event: string | IEvent, payload?: any): Promise<any[]>\n\n  /**\n   * Dispatch an event and halt when the first listener returns a non-null response.\n   *\n   * @param {string | IEvent} event - The event name or object\n   * @param {any} [payload] - The event payload (if event is a string)\n   * @returns {Promise<any>} The first non-null response or null\n   */\n  until(event: string | IEvent, payload?: any): Promise<any>\n\n  /**\n   * Remove a set of listeners from the dispatcher.\n   *\n   * @param {string} event - The event name\n   */\n  forget(event: string): void\n\n  /**\n   * Remove all listeners from the dispatcher.\n   */\n  forgetAll(): void\n\n  /**\n   * Get an observable of all events\n   *\n   * @returns An observable of all events\n   */\n  events(): Observable<IEventData>\n\n  /**\n   * Get an observable of events with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of events with the specified name\n   */\n  ofType(eventName: string): Observable<IEventData>\n\n  /**\n   * Get an observable of events of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of events of the specified class\n   */\n  ofClass<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<IEventData<T>>\n\n  /**\n   * Get an observable of event payloads with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of event payloads with the specified name\n   */\n  on<T = any>(eventName: string): Observable<T>\n\n  /**\n   * Get an observable of event payloads of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of event payloads of the specified class\n   */\n  onEvent<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<T>\n\n  /**\n   * Get the number of listeners for a specific event\n   *\n   * @param eventName - The event name\n   * @returns The number of listeners\n   */\n  listenerCount(eventName: string): number\n}\n\n/**\n * DI token for IEventDispatcher interface\n */\nexport namespace IEventDispatcher {\n  export const $ = Symbol.for('IEventDispatcher')\n}\n","import type { IEventDispatcher } from './dispatcher.interface'\n\n/**\n * Interface for event subscribers.\n * Subscribers can listen to multiple events and register multiple listeners.\n */\nexport interface ISubscriber {\n  /**\n   * Register the listeners for the subscriber.\n   * This method is called when the subscriber is registered with the dispatcher.\n   *\n   * @param {IEventDispatcher} dispatcher - The event dispatcher\n   */\n  subscribe(dispatcher: IEventDispatcher): void\n}\n\n/**\n * DI token for ISubscriber interface\n */\nexport namespace ISubscriber {\n  export const $ = Symbol.for('ISubscriber')\n}\n"]}