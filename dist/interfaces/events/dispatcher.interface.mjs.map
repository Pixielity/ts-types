{"version":3,"sources":["../../../src/interfaces/events/dispatcher.interface.ts"],"names":["IEventDispatcher"],"mappings":";;;;;;;;;;;AAoHiB,IAAA;AAAA,CAAV,CAAUA,iBAAV,KAAA;AACE,EAAMA,iBAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,kBAAkB,CAAA;AAAA,CAD/B,EAAA,gBAAA,KAAA,gBAAA,GAAA,EAAA,CAAA,CAAA","file":"dispatcher.interface.mjs","sourcesContent":["import type { Observable } from 'rxjs'\nimport type { IEvent } from './event.interface'\nimport type { IListener } from './listener.interface'\nimport type { ISubscriber } from './subscriber.interface'\nimport type { IEventData } from './event-data.interface'\n\n/**\n * Interface for the event dispatcher.\n * The dispatcher is responsible for registering listeners and dispatching events.\n */\nexport interface IEventDispatcher {\n  /**\n   * Register an event listener with the dispatcher.\n   *\n   * @param {string} event - The event name\n   * @param {IListener | Function} listener - The listener function or object\n   * @returns {() => void} A function to remove the listener\n   */\n  listen(event: string, listener: IListener | Function): () => void\n\n  /**\n   * Determine if a given event has listeners.\n   *\n   * @param {string} eventName - The event name\n   * @returns {boolean} True if the event has listeners\n   */\n  hasListeners(eventName: string): boolean\n\n  /**\n   * Register an event subscriber with the dispatcher.\n   *\n   * @param {ISubscriber} subscriber - The subscriber to register\n   */\n  subscribe(subscriber: ISubscriber): void\n\n  /**\n   * Dispatch an event and call the listeners.\n   *\n   * @param {string | IEvent} event - The event name or object\n   * @param {any} [payload] - The event payload (if event is a string)\n   * @returns {Promise<any[]>} Array of results from the listeners\n   */\n  dispatch(event: string | IEvent, payload?: any): Promise<any[]>\n\n  /**\n   * Dispatch an event and halt when the first listener returns a non-null response.\n   *\n   * @param {string | IEvent} event - The event name or object\n   * @param {any} [payload] - The event payload (if event is a string)\n   * @returns {Promise<any>} The first non-null response or null\n   */\n  until(event: string | IEvent, payload?: any): Promise<any>\n\n  /**\n   * Remove a set of listeners from the dispatcher.\n   *\n   * @param {string} event - The event name\n   */\n  forget(event: string): void\n\n  /**\n   * Remove all listeners from the dispatcher.\n   */\n  forgetAll(): void\n\n  /**\n   * Get an observable of all events\n   *\n   * @returns An observable of all events\n   */\n  events(): Observable<IEventData>\n\n  /**\n   * Get an observable of events with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of events with the specified name\n   */\n  ofType(eventName: string): Observable<IEventData>\n\n  /**\n   * Get an observable of events of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of events of the specified class\n   */\n  ofClass<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<IEventData<T>>\n\n  /**\n   * Get an observable of event payloads with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of event payloads with the specified name\n   */\n  on<T = any>(eventName: string): Observable<T>\n\n  /**\n   * Get an observable of event payloads of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of event payloads of the specified class\n   */\n  onEvent<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<T>\n\n  /**\n   * Get the number of listeners for a specific event\n   *\n   * @param eventName - The event name\n   * @returns The number of listeners\n   */\n  listenerCount(eventName: string): number\n}\n\n/**\n * DI token for IEventDispatcher interface\n */\nexport namespace IEventDispatcher {\n  export const $ = Symbol.for('IEventDispatcher')\n}\n"]}