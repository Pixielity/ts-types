{"version":3,"sources":["../../../src/interfaces/queue/queueable.interface.ts","../../../src/interfaces/queue/should-queue.interface.ts","../../../src/interfaces/queue/queue-connection.interface.ts","../../../src/interfaces/queue/queue-manager.interface.ts","../../../src/interfaces/queue/job-registry.interface.ts","../../../src/interfaces/queue/worker.interface.ts"],"names":["IQueueable","IShouldQueue","IQueueConnection","IQueueManager","IJobRegistry","IWorker"],"mappings":";;;;;;;;;;;;;AA+EiBA;AAAA,CAAV,CAAUA,WAAV,KAAA;AACE,EAAMA,WAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,YAAY,CAAA;AAAA,CADzB,EAAAA,kBAAA,KAAAA,kBAAA,GAAA,EAAA,CAAA,CAAA;;;AC1CAC;AAAA,CAAV,CAAUA,aAAV,KAAA;AACE,EAAMA,aAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,cAAc,CAAA;AAAA,CAD3B,EAAAA,oBAAA,KAAAA,oBAAA,GAAA,EAAA,CAAA,CAAA;;;ACiLAC;AAAA,CAAV,CAAUA,iBAAV,KAAA;AACE,EAAMA,iBAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,kBAAkB,CAAA;AAAA,CAD/B,EAAAA,wBAAA,KAAAA,wBAAA,GAAA,EAAA,CAAA,CAAA;;;AC9DAC;AAAA,CAAV,CAAUA,cAAV,KAAA;AACE,EAAMA,cAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,eAAe,CAAA;AAAA,CAD5B,EAAAA,qBAAA,KAAAA,qBAAA,GAAA,EAAA,CAAA,CAAA;;;AC9FAC;AAAA,CAAV,CAAUA,aAAV,KAAA;AACE,EAAMA,aAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,cAAc,CAAA;AAAA,CAD3B,EAAAA,oBAAA,KAAAA,oBAAA,GAAA,EAAA,CAAA,CAAA;;;ACmBAC;AAAA,CAAV,CAAUA,QAAV,KAAA;AACE,EAAMA,QAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,SAAS,CAAA;AAAA,CADtB,EAAAA,eAAA,KAAAA,eAAA,GAAA,EAAA,CAAA,CAAA","file":"index.js","sourcesContent":["import type { IShouldQueue } from './should-queue.interface'\n\n/**\n * Interface for queueable jobs.\n * Queueable items can be processed asynchronously through a queue.\n */\nexport interface IQueueable extends IShouldQueue {\n  /**\n   * Handle the job.\n   *\n   * @param data - The job data\n   * @returns Promise resolving when the job is complete\n   */\n  handle(data: any): Promise<void>\n\n  /**\n   * Get the middleware the job should pass through.\n   *\n   * @returns Array of middleware names\n   */\n  middleware?(): string[]\n\n  /**\n   * Determine if the job should be encrypted.\n   *\n   * @returns True if the job should be encrypted\n   */\n  shouldBeEncrypted?(): boolean\n\n  /**\n   * The number of times the job may be attempted.\n   *\n   * @returns The maximum number of attempts\n   */\n  tries?(): number\n\n  /**\n   * The number of seconds the job can run before timing out.\n   *\n   * @returns The timeout in seconds\n   */\n  timeout?(): number\n\n  /**\n   * Calculate the number of seconds to wait before retrying the job.\n   *\n   * @param attempt - The current attempt number\n   * @returns The number of seconds to wait\n   */\n  retryAfter?(attempt: number): number\n\n  /**\n   * Determine if the job should be released back onto the queue.\n   *\n   * @param error - The error that caused the job to fail\n   * @returns True if the job should be released\n   */\n  shouldRelease?(error: Error): boolean\n\n  /**\n   * Handle a job failure.\n   *\n   * @param error - The error that caused the job to fail\n   * @returns Promise resolving when the failure is handled\n   */\n  failed?(error: Error): Promise<void>\n\n  /**\n   * Report progress of the job.\n   *\n   * @param progress - The progress percentage (0-100)\n   * @param data - Additional progress data\n   */\n  reportProgress?(progress: number, data?: any): Promise<void>\n}\n\n/**\n * DI token for IQueueable interface\n */\nexport namespace IQueueable {\n  export const $ = Symbol.for('IQueueable')\n}\n","/**\n * Interface for objects that can be queued.\n * Implementing this interface indicates that the object should be processed asynchronously.\n */\nexport interface IShouldQueue {\n  /**\n   * Determine if the object should be queued.\n   *\n   * @returns {boolean} True if the object should be queued\n   */\n  shouldQueue(): boolean\n\n  /**\n   * Get the connection the job should be sent to.\n   *\n   * @returns {string|null} The connection name or null for the default\n   */\n  connection?(): string | null\n\n  /**\n   * Get the queue the job should be sent to.\n   *\n   * @returns {string|null} The queue name or null for the default\n   */\n  queue?(): string | null\n\n  /**\n   * Get the delay (in seconds) before the job should be processed.\n   *\n   * @returns {number} The number of seconds to delay\n   */\n  delay?(): number\n}\n\n/**\n * DI token for IShouldQueue interface\n */\nexport namespace IShouldQueue {\n  export const $ = Symbol.for('IShouldQueue')\n}\n","import type { IQueueable } from './queueable.interface'\n\n/**\n * Interface for queue connections.\n * Queue connections are responsible for processing queueable jobs.\n */\nexport interface IQueueConnection {\n  /**\n   * Set the key prefix for queue items.\n   *\n   * @param prefix - The prefix to use\n   */\n  setKeyPrefix(prefix: string): void\n\n  /**\n   * Push a new job onto the queue.\n   *\n   * @param job - The job to queue\n   * @param data - Additional data for the job\n   * @param queue - The queue to push to\n   * @returns Promise resolving when the job is pushed\n   */\n  push(job: IQueueable, data: any, queue?: string): Promise<void>\n\n  /**\n   * Push a new job onto the queue after a delay.\n   *\n   * @param delay - The delay in seconds\n   * @param job - The job to queue\n   * @param data - Additional data for the job\n   * @param queue - The queue to push to\n   * @returns Promise resolving when the job is pushed\n   */\n  later(delay: number, job: IQueueable, data: any, queue?: string): Promise<void>\n\n  /**\n   * Push an array of jobs onto the queue.\n   *\n   * @param jobs - The jobs to queue\n   * @param data - Additional data for the jobs\n   * @param queue - The queue to push to\n   * @returns Promise resolving when all jobs are pushed\n   */\n  bulk(jobs: IQueueable[], data: any, queue?: string): Promise<void>\n\n  /**\n   * Process jobs in a queue.\n   *\n   * @param queue - The queue to process\n   * @param count - The number of jobs to process\n   * @returns The number of jobs processed\n   */\n  process(queue?: string, count?: number): Promise<number>\n\n  /**\n   * Get the number of jobs in a queue.\n   *\n   * @param queue - The queue name\n   * @returns The number of jobs\n   */\n  size(queue?: string): Promise<number>\n\n  /**\n   * Get the number of delayed jobs in a queue.\n   *\n   * @param queue - The queue name\n   * @returns The number of delayed jobs\n   */\n  delayedSize(queue?: string): Promise<number>\n\n  /**\n   * Clear all jobs in a queue.\n   *\n   * @param queue - The queue to clear\n   * @returns Promise resolving when the queue is cleared\n   */\n  clear(queue?: string): Promise<void>\n\n  /**\n   * Clear all queues.\n   *\n   * @returns Promise resolving when all queues are cleared\n   */\n  clearAll(): Promise<void>\n\n  /**\n   * Release a job back onto the queue.\n   *\n   * @param job - The job to release\n   * @param data - The job data\n   * @param delay - The delay in seconds\n   * @param queue - The queue to release to\n   * @returns Promise resolving when the job is released\n   */\n  release(job: IQueueable, data: any, delay?: number, queue?: string): Promise<void>\n\n  /**\n   * Move a job to the failed queue.\n   *\n   * @param job - The failed job\n   * @param data - The job data\n   * @param error - The error that caused the failure\n   * @returns Promise resolving when the job is moved\n   */\n  failed(job: IQueueable, data: any, error: Error): Promise<void>\n\n  /**\n   * Report progress for a job.\n   *\n   * @param job - The job to report progress for\n   * @param data - The job data\n   * @param progress - The progress percentage (0-100)\n   * @param progressData - Additional progress data\n   * @returns Promise resolving when the progress is reported\n   */\n  reportProgress?(job: IQueueable, data: any, progress: number, progressData?: any): Promise<void>\n\n  /**\n   * Listen for job events.\n   *\n   * @param event - The event name\n   * @param callback - The callback function\n   * @returns A function to remove the listener\n   */\n  on?(event: string, callback: (data: any) => void): () => void\n\n  /**\n   * Get all queues.\n   *\n   * @returns Promise resolving with an array of queue names\n   */\n  getQueues(): Promise<string[]>\n\n  /**\n   * Get all jobs in a queue.\n   *\n   * @param queue - The queue name\n   * @returns Promise resolving with an array of jobs\n   */\n  getJobs(\n    queue?: string,\n  ): Promise<Array<{ id: string; job: IQueueable; data: any; executeAt: number; attempts: number }>>\n\n  /**\n   * Get all failed jobs.\n   *\n   * @returns Promise resolving with an array of failed jobs\n   */\n  getFailedJobs(): Promise<\n    Array<{ id: string; job: IQueueable; data: any; error: Error; failedAt: number }>\n  >\n\n  /**\n   * Retry a failed job.\n   *\n   * @param id - The ID of the failed job\n   * @returns Promise resolving when the job is retried\n   */\n  retryFailed(id: string): Promise<void>\n\n  /**\n   * Retry all failed jobs.\n   *\n   * @returns Promise resolving with the number of jobs retried\n   */\n  retryAllFailed(): Promise<number>\n\n  /**\n   * Delete a failed job.\n   *\n   * @param id - The ID of the failed job\n   * @returns Promise resolving when the job is deleted\n   */\n  forgetFailed(id: string): Promise<void>\n\n  /**\n   * Delete all failed jobs.\n   *\n   * @returns Promise resolving when all failed jobs are deleted\n   */\n  flushFailed(): Promise<void>\n\n  /**\n   * Store a restart signal.\n   *\n   * @returns Promise resolving when the signal is stored\n   */\n  storeRestartSignal(): Promise<void>\n\n  /**\n   * Store a stop signal.\n   *\n   * @returns Promise resolving when the signal is stored\n   */\n  storeStopSignal(): Promise<void>\n\n  /**\n   * Check if a restart signal exists.\n   *\n   * @returns Promise resolving with true if a restart signal exists\n   */\n  shouldRestart(): Promise<boolean>\n\n  /**\n   * Check if a stop signal exists.\n   *\n   * @returns Promise resolving with true if a stop signal exists\n   */\n  shouldStop(): Promise<boolean>\n}\n\n/**\n * DI token for IQueueConnection interface\n */\nexport namespace IQueueConnection {\n  export const $ = Symbol.for('IQueueConnection')\n}\n","import type { IQueueConnection } from './queue-connection.interface'\nimport type { IQueueable } from './queueable.interface'\nimport { IWorker } from './worker.interface'\n\n/**\n * Interface for the queue manager.\n * The queue manager is responsible for managing queue connections and dispatching jobs.\n */\nexport interface IQueueManager {\n  /**\n   * Add a queue connection.\n   *\n   * @param name - The connection name\n   * @param connection - The queue connection\n   */\n  addConnection(name: string, connection: IQueueConnection): void\n\n  /**\n   * Get a queue connection by name.\n   *\n   * @param name - The connection name (or default if not provided)\n   * @returns The queue connection\n   */\n  connection(name?: string): IQueueConnection\n\n  /**\n   * Set the default connection name.\n   *\n   * @param name - The default connection name\n   */\n  setDefaultConnection(name: string): void\n\n  /**\n   * Create a worker for a connection and queue.\n   *\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns The worker\n   */\n  createWorker(connectionName?: string, queue?: string): IWorker\n\n  /**\n   * Push a new job onto the queue.\n   *\n   * @param job - The job to queue\n   * @param data - Additional data for the job\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns Promise resolving when the job is pushed\n   */\n  push(\n    job: IQueueable,\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Push a new job onto the queue after a delay.\n   *\n   * @param delay - The delay in seconds\n   * @param job - The job to queue\n   * @param data - Additional data for the job\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns Promise resolving when the job is pushed\n   */\n  later(\n    delay: number,\n    job: IQueueable,\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Push an array of jobs onto the queue.\n   *\n   * @param jobs - The jobs to queue\n   * @param data - Additional data for the jobs\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns Promise resolving when all jobs are pushed\n   */\n  bulk(\n    jobs: IQueueable[],\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Release a job back onto the queue.\n   *\n   * @param job - The job to release\n   * @param data - The job data\n   * @param delay - The delay in seconds\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns Promise resolving when the job is released\n   */\n  release(\n    job: IQueueable,\n    data: any,\n    delay?: number,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Move a job to the failed queue.\n   *\n   * @param job - The failed job\n   * @param data - The job data\n   * @param error - The error that caused the failure\n   * @param connectionName - The connection name\n   * @returns Promise resolving when the job is moved\n   */\n  failed(job: IQueueable, data: any, error: Error, connectionName?: string | null): Promise<void>\n\n  /**\n   * Report progress for a job.\n   *\n   * @param job - The job to report progress for\n   * @param data - The job data\n   * @param progress - The progress percentage (0-100)\n   * @param progressData - Additional progress data\n   * @param connectionName - The connection name\n   * @returns Promise resolving when the progress is reported\n   */\n  reportProgress(\n    job: IQueueable,\n    data: any,\n    progress: number,\n    progressData?: any,\n    connectionName?: string | null,\n  ): Promise<void>\n\n  /**\n   * Listen for job events.\n   *\n   * @param event - The event name\n   * @param callback - The callback function\n   * @param connectionName - The connection name\n   * @returns A function to remove the listener\n   */\n  on(event: string, callback: (data: any) => void, connectionName?: string | null): () => void\n}\n\n/**\n * DI token for IQueueManager interface\n */\nexport namespace IQueueManager {\n  export const $ = Symbol.for('IQueueManager')\n}\n","import type { IQueueable } from './queueable.interface'\n\n/**\n * Interface for job registry\n * The job registry is responsible for registering and resolving job classes\n */\nexport interface IJobRegistry {\n  /**\n   * Register a job class.\n   *\n   * @param name - The name of the job class\n   * @param jobClass - The job class constructor\n   */\n  register(name: string, jobClass: new (...args: any[]) => IQueueable): void\n\n  /**\n   * Register multiple job classes.\n   *\n   * @param jobClasses - Map of job class names to constructors\n   */\n  registerMany(jobClasses: Map<string, new (...args: any[]) => IQueueable>): void\n\n  /**\n   * Check if a job class is registered.\n   *\n   * @param name - The name of the job class\n   * @returns True if the job class is registered\n   */\n  has(name: string): boolean\n\n  /**\n   * Get a job class by name.\n   *\n   * @param name - The name of the job class\n   * @returns The job class constructor\n   */\n  get(name: string): new (...args: any[]) => IQueueable\n\n  /**\n   * Create a new instance of a job class.\n   *\n   * @param name - The name of the job class\n   * @param args - Arguments to pass to the constructor\n   * @returns A new instance of the job class\n   */\n  make(name: string, ...args: any[]): IQueueable\n\n  /**\n   * Get all registered job classes.\n   *\n   * @returns Map of job class names to constructors\n   */\n  all(): Map<string, new (...args: any[]) => IQueueable>\n}\n\n/**\n * DI token for IJobRegistry interface\n */\nexport namespace IJobRegistry {\n  export const $ = Symbol.for('IJobRegistry')\n}\n","import { WorkerStatus } from '../../enums'\n\n/**\n * Interface for queue workers.\n * Workers are responsible for processing jobs from a queue.\n */\nexport interface IWorker {\n  /**\n   * Start the worker.\n   *\n   * @returns Promise resolving when the worker is started\n   */\n  start(): Promise<void>\n\n  /**\n   * Stop the worker.\n   *\n   * @returns Promise resolving when the worker is stopped\n   */\n  stop(): Promise<void>\n\n  /**\n   * Process the next job on the queue.\n   *\n   * @param queue - The queue to process\n   * @returns Promise resolving to true if a job was processed\n   */\n  processNext(queue?: string): Promise<boolean>\n\n  /**\n   * Get the current status of the worker.\n   *\n   * @returns The worker status\n   */\n  getStatus(): WorkerStatus\n\n  /**\n   * Set the maximum number of attempts for failed jobs.\n   *\n   * @param maxAttempts - The maximum number of attempts\n   */\n  setMaxAttempts(maxAttempts: number): void\n\n  /**\n   * Set the timeout for jobs.\n   *\n   * @param timeout - The timeout in seconds\n   */\n  setTimeout(timeout: number): void\n\n  /**\n   * Set the sleep time between polling the queue.\n   *\n   * @param sleep - The sleep time in seconds\n   */\n  setSleep(sleep: number): void\n\n  /**\n   * Set the concurrency level.\n   *\n   * @param concurrency - The number of jobs to process concurrently\n   */\n  setConcurrency(concurrency: number): void\n\n  /**\n   * Listen for worker events.\n   *\n   * @param event - The event name\n   * @param callback - The callback function\n   * @returns A function to remove the listener\n   */\n  on(event: string, callback: (data: any) => void): () => void\n}\n\n/**\n * DI token for IWorker interface\n */\nexport namespace IWorker {\n  export const $ = Symbol.for('IWorker')\n}\n"]}