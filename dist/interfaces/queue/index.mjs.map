{"version":3,"sources":["../../../src/interfaces/queue/queueable.interface.ts","../../../src/interfaces/queue/should-queue.interface.ts","../../../src/interfaces/queue/queue-connection.interface.ts","../../../src/interfaces/queue/queue-manager.interface.ts","../../../src/interfaces/queue/job-registry.interface.ts","../../../src/interfaces/queue/worker.interface.ts"],"names":["IQueueable","IShouldQueue","IQueueConnection","IQueueManager","IJobRegistry","IWorker"],"mappings":";;;;;;;;;;;AAsFiB,IAAA;AAAA,CAAV,CAAUA,WAAV,KAAA;AACE,EAAMA,WAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,YAAY,CAAA;AAAA,CADzB,EAAA,UAAA,KAAA,UAAA,GAAA,EAAA,CAAA,CAAA;;;ACjDA,IAAA;AAAA,CAAV,CAAUC,aAAV,KAAA;AACE,EAAMA,aAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,cAAc,CAAA;AAAA,CAD3B,EAAA,YAAA,KAAA,YAAA,GAAA,EAAA,CAAA,CAAA;;;ACuFA,IAAA;AAAA,CAAV,CAAUC,iBAAV,KAAA;AACE,EAAMA,iBAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,kBAAkB,CAAA;AAAA,CAD/B,EAAA,gBAAA,KAAA,gBAAA,GAAA,EAAA,CAAA,CAAA;;;ACIA,IAAA;AAAA,CAAV,CAAUC,cAAV,KAAA;AACE,EAAMA,cAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,eAAe,CAAA;AAAA,CAD5B,EAAA,aAAA,KAAA,aAAA,GAAA,EAAA,CAAA,CAAA;;;ACtDA,IAAA;AAAA,CAAV,CAAUC,aAAV,KAAA;AACE,EAAMA,aAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,cAAc,CAAA;AAAA,CAD3B,EAAA,YAAA,KAAA,YAAA,GAAA,EAAA,CAAA,CAAA;;;ACeA,IAAA;AAAA,CAAV,CAAUC,QAAV,KAAA;AACE,EAAMA,QAAA,CAAA,CAAA,GAAI,MAAO,CAAA,GAAA,CAAI,SAAS,CAAA;AAAA,CADtB,EAAA,OAAA,KAAA,OAAA,GAAA,EAAA,CAAA,CAAA","file":"index.mjs","sourcesContent":["import type { IShouldQueue } from './should-queue.interface'\n\n/**\n * Interface for queueable jobs.\n * Queueable items can be processed asynchronously through a queue.\n */\nexport interface IQueueable extends IShouldQueue {\n  /**\n   * Get the middleware the job should pass through.\n   *\n   * @returns {string[]} Array of middleware names\n   */\n  middleware?(): string[]\n\n  /**\n   * Determine if the job should be encrypted.\n   *\n   * @returns {boolean} Whether the job should be encrypted\n   */\n  shouldBeEncrypted?(): boolean\n\n  /**\n   * Handle the job.\n   * This method is called when the job is processed from the queue.\n   *\n   * @param {any} data - The job data\n   * @returns {Promise<void> | void} - May return a promise for async handling\n   */\n  handle(data: any): Promise<void> | void\n\n  /**\n   * Handle a job failure.\n   *\n   * @param {Error} error - The error that caused the failure\n   * @returns {Promise<void> | void} - May return a promise for async handling\n   */\n  failed?(error: Error): Promise<void> | void\n\n  /**\n   * The number of times the job may be attempted.\n   *\n   * @returns {number} The number of attempts\n   */\n  tries?(): number\n\n  /**\n   * The number of seconds to wait before retrying a job that has failed.\n   *\n   * @returns {number} The number of seconds to wait\n   */\n  backoff?(): number\n\n  /**\n   * The maximum number of unhandled exceptions to allow before failing.\n   *\n   * @returns {number} The number of exceptions allowed\n   */\n  maxExceptions?(): number\n\n  /**\n   * Determine if the job should be released back onto the queue.\n   *\n   * @param {Error} error - The error that caused the release\n   * @returns {boolean} True if the job should be released\n   */\n  shouldRelease?(error: Error): boolean\n\n  /**\n   * Calculate the number of seconds to wait before retrying the job.\n   *\n   * @param {number} attempt - The number of attempts that have been made\n   * @returns {number} The number of seconds to wait\n   */\n  retryAfter?(attempt: number): number\n\n  /**\n   * Get the timeout for the job.\n   *\n   * @returns {number} The timeout in seconds\n   */\n  timeout?(): number\n}\n\n/**\n * DI token for IQueueable interface\n */\nexport namespace IQueueable {\n  export const $ = Symbol.for('IQueueable')\n}\n","/**\n * Interface for objects that can be queued.\n * Implementing this interface indicates that the object should be processed asynchronously.\n */\nexport interface IShouldQueue {\n  /**\n   * Determine if the object should be queued.\n   *\n   * @returns {boolean} True if the object should be queued\n   */\n  shouldQueue(): boolean\n\n  /**\n   * Get the connection the job should be sent to.\n   *\n   * @returns {string|null} The connection name or null for the default\n   */\n  connection?(): string | null\n\n  /**\n   * Get the queue the job should be sent to.\n   *\n   * @returns {string|null} The queue name or null for the default\n   */\n  queue?(): string | null\n\n  /**\n   * Get the delay (in seconds) before the job should be processed.\n   *\n   * @returns {number} The number of seconds to delay\n   */\n  delay?(): number\n}\n\n/**\n * DI token for IShouldQueue interface\n */\nexport namespace IShouldQueue {\n  export const $ = Symbol.for('IShouldQueue')\n}\n","import type { IQueueable } from './queueable.interface'\n\n/**\n * Interface for queue connections.\n * Queue connections are responsible for processing queueable jobs.\n */\nexport interface IQueueConnection {\n  /**\n   * Push a new job onto the queue.\n   *\n   * @param {IQueueable} job - The job to queue\n   * @param {any} data - Additional data for the job\n   * @param {string} [queue] - The queue to push to\n   * @returns {Promise<void>}\n   */\n  push(job: IQueueable, data: any, queue?: string): Promise<void>\n\n  /**\n   * Push a new job onto the queue after a delay.\n   *\n   * @param {number} delay - The delay in seconds\n   * @param {IQueueable} job - The job to queue\n   * @param {any} data - Additional data for the job\n   * @param {string} [queue] - The queue to push to\n   * @returns {Promise<void>}\n   */\n  later(delay: number, job: IQueueable, data: any, queue?: string): Promise<void>\n\n  /**\n   * Push an array of jobs onto the queue.\n   *\n   * @param {IQueueable[]} jobs - The jobs to queue\n   * @param {any} data - Additional data for the jobs\n   * @param {string} [queue] - The queue to push to\n   * @returns {Promise<void>}\n   */\n  bulk(jobs: IQueueable[], data: any, queue?: string): Promise<void>\n\n  /**\n   * Process jobs in a queue.\n   *\n   * @param {string} [queue] - The queue to process\n   * @param {number} [count=1] - The number of jobs to process\n   * @returns {Promise<number>} The number of jobs processed\n   */\n  process(queue?: string, count?: number): Promise<number>\n\n  /**\n   * Get the number of jobs in a queue.\n   *\n   * @param {string} [queue] - The queue name\n   * @returns {Promise<number>} The number of jobs\n   */\n  size(queue?: string): Promise<number>\n\n  /**\n   * Get the number of delayed jobs in a queue.\n   *\n   * @param {string} [queue] - The queue name\n   * @returns {Promise<number>} The number of delayed jobs\n   */\n  delayedSize(queue?: string): Promise<number>\n\n  /**\n   * Clear all jobs in a queue.\n   *\n   * @param {string} [queue] - The queue to clear\n   * @returns {Promise<void>}\n   */\n  clear(queue?: string): Promise<void>\n\n  /**\n   * Clear all queues.\n   *\n   * @returns {Promise<void>}\n   */\n  clearAll(): Promise<void>\n\n  /**\n   * Release a job back onto the queue.\n   *\n   * @param {IQueueable} job - The job to release\n   * @param {any} data - The job data\n   * @param {number} [delay=0] - The delay in seconds\n   * @param {string} [queue] - The queue to release to\n   * @returns {Promise<void>}\n   */\n  release(job: IQueueable, data: any, delay?: number, queue?: string): Promise<void>\n\n  /**\n   * Move a job to the failed queue.\n   *\n   * @param {IQueueable} job - The failed job\n   * @param {any} data - The job data\n   * @param {Error} error - The error that caused the failure\n   * @returns {Promise<void>}\n   */\n  failed(job: IQueueable, data: any, error: Error): Promise<void>\n\n  /**\n   * Get the name of the connection.\n   *\n   * @returns {string} The connection name\n   */\n  getName(): string\n\n  /**\n   * Get the default queue for the connection.\n   *\n   * @returns {string} The default queue name\n   */\n  getDefaultQueue(): string\n\n  /**\n   * Set the default queue for the connection.\n   *\n   * @param {string} queue - The default queue name\n   */\n  setDefaultQueue(queue: string): void\n}\n\n/**\n * DI token for IQueueConnection interface\n */\nexport namespace IQueueConnection {\n  export const $ = Symbol.for('IQueueConnection')\n}\n","import type { IQueueConnection } from './queue-connection.interface'\nimport type { IQueueable } from './queueable.interface'\n\n/**\n * Interface for the queue manager.\n * The queue manager is responsible for managing queue connections and dispatching jobs.\n */\nexport interface IQueueManager {\n  /**\n   * Add a queue connection.\n   *\n   * @param {string} name - The connection name\n   * @param {IQueueConnection} connection - The queue connection\n   */\n  addConnection(name: string, connection: IQueueConnection): void\n\n  /**\n   * Get a queue connection by name.\n   *\n   * @param {string} [name] - The connection name (or default if not provided)\n   * @returns {IQueueConnection} The queue connection\n   */\n  connection(name?: string): IQueueConnection\n\n  /**\n   * Set the default connection name.\n   *\n   * @param {string} name - The default connection name\n   */\n  setDefaultConnection(name: string): void\n\n  /**\n   * Push a new job onto the queue.\n   *\n   * @param {IQueueable} job - The job to queue\n   * @param {any} data - Additional data for the job\n   * @param {string} [connectionName] - The connection name\n   * @param {string} [queue] - The queue name\n   * @returns {Promise<void>}\n   */\n  push(\n    job: IQueueable,\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Push a new job onto the queue after a delay.\n   *\n   * @param {number} delay - The delay in seconds\n   * @param {IQueueable} job - The job to queue\n   * @param {any} data - Additional data for the job\n   * @param {string} [connectionName] - The connection name\n   * @param {string} [queue] - The queue name\n   * @returns {Promise<void>}\n   */\n  later(\n    delay: number,\n    job: IQueueable,\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Push an array of jobs onto the queue.\n   *\n   * @param {IQueueable[]} jobs - The jobs to queue\n   * @param {any} data - Additional data for the jobs\n   * @param {string} [connectionName] - The connection name\n   * @param {string} [queue] - The queue name\n   * @returns {Promise<void>}\n   */\n  bulk(\n    jobs: IQueueable[],\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Release a job back onto the queue.\n   *\n   * @param {IQueueable} job - The job to release\n   * @param {any} data - The job data\n   * @param {number} [delay=0] - The delay in seconds\n   * @param {string} [connectionName] - The connection name\n   * @param {string} [queue] - The queue name\n   * @returns {Promise<void>}\n   */\n  release(\n    job: IQueueable,\n    data: any,\n    delay?: number,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Move a job to the failed queue.\n   *\n   * @param {IQueueable} job - The failed job\n   * @param {any} data - The job data\n   * @param {Error} error - The error that caused the failure\n   * @param {string} [connectionName] - The connection name\n   * @returns {Promise<void>}\n   */\n  failed(job: IQueueable, data: any, error: Error, connectionName?: string | null): Promise<void>\n\n  /**\n   * Get the default connection name.\n   *\n   * @returns {string} The default connection name\n   */\n  getDefaultConnection(): string\n\n  /**\n   * Get all registered connections.\n   *\n   * @returns {Record<string, IQueueConnection>} The registered connections\n   */\n  getConnections(): Record<string, IQueueConnection>\n}\n\n/**\n * DI token for IQueueManager interface\n */\nexport namespace IQueueManager {\n  export const $ = Symbol.for('IQueueManager')\n}\n","import type { IQueueable } from './queueable.interface'\n\n/**\n * Interface for job registry\n * The job registry is responsible for registering and resolving job classes\n */\nexport interface IJobRegistry {\n  /**\n   * Register a job class\n   *\n   * @param name - The name of the job class\n   * @param jobClass - The job class constructor\n   */\n  register(name: string, jobClass: new (...args: any[]) => IQueueable): void\n\n  /**\n   * Register multiple job classes\n   *\n   * @param jobClasses - Map of job class names to constructors\n   */\n  registerMany(jobClasses: Map<string, new (...args: any[]) => IQueueable>): void\n\n  /**\n   * Check if a job class is registered\n   *\n   * @param name - The name of the job class\n   * @returns True if the job class is registered\n   */\n  has(name: string): boolean\n\n  /**\n   * Get a job class by name\n   *\n   * @param name - The name of the job class\n   * @returns The job class constructor\n   * @throws Error if the job class is not registered\n   */\n  get(name: string): new (...args: any[]) => IQueueable\n\n  /**\n   * Create a new instance of a job class\n   *\n   * @param name - The name of the job class\n   * @param args - Arguments to pass to the constructor\n   * @returns A new instance of the job class\n   * @throws Error if the job class is not registered\n   */\n  make(name: string, ...args: any[]): IQueueable\n\n  /**\n   * Get all registered job classes\n   *\n   * @returns Map of job class names to constructors\n   */\n  all(): Map<string, new (...args: any[]) => IQueueable>\n\n  /**\n   * Register a job class using its class name\n   *\n   * @param jobClass - The job class constructor\n   */\n  registerClass(jobClass: new (...args: any[]) => IQueueable): void\n\n  /**\n   * Remove a job class from the registry\n   *\n   * @param name - The name of the job class\n   */\n  unregister(name: string): void\n}\n\n/**\n * DI token for IJobRegistry interface\n */\nexport namespace IJobRegistry {\n  export const $ = Symbol.for('IJobRegistry')\n}\n","/**\n * Interface for queue workers.\n * Workers are responsible for processing jobs from a queue.\n */\nexport interface IWorker {\n  /**\n   * Start the worker.\n   *\n   * @returns {Promise<void>}\n   */\n  start(): Promise<void>\n\n  /**\n   * Stop the worker.\n   *\n   * @returns {Promise<void>}\n   */\n  stop(): Promise<void>\n\n  /**\n   * Process the next job on the queue.\n   *\n   * @param {string} [queue] - The queue to process\n   * @returns {Promise<boolean>} True if a job was processed\n   */\n  processNext(queue?: string): Promise<boolean>\n\n  /**\n   * Get the current status of the worker.\n   *\n   * @returns {string} The worker status\n   */\n  getStatus(): string\n\n  /**\n   * Set the maximum number of attempts for failed jobs.\n   *\n   * @param {number} maxAttempts - The maximum number of attempts\n   */\n  setMaxAttempts(maxAttempts: number): void\n\n  /**\n   * Set the timeout for jobs.\n   *\n   * @param {number} timeout - The timeout in seconds\n   */\n  setTimeout(timeout: number): void\n\n  /**\n   * Set the sleep time between polling the queue.\n   *\n   * @param {number} sleep - The sleep time in seconds\n   */\n  setSleep(sleep: number): void\n\n  /**\n   * Get the worker ID.\n   *\n   * @returns {string} The worker ID\n   */\n  getId(): string\n\n  /**\n   * Get the number of jobs processed by this worker.\n   *\n   * @returns {number} The number of jobs processed\n   */\n  getProcessedCount(): number\n\n  /**\n   * Get the number of failed jobs.\n   *\n   * @returns {number} The number of failed jobs\n   */\n  getFailedCount(): number\n\n  /**\n   * Register an event handler for worker events.\n   *\n   * @param {string} event - The event name\n   * @param {Function} handler - The event handler\n   * @returns {() => void} A function to remove the event handler\n   */\n  on(event: string, handler: Function): () => void\n}\n\n/**\n * DI token for IWorker interface\n */\nexport namespace IWorker {\n  export const $ = Symbol.for('IWorker')\n}\n"]}