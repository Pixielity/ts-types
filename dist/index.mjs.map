{"version":3,"sources":["../src/interfaces/application/application.interface.ts","../src/interfaces/application/service-provider.inteface.ts","../src/interfaces/cache/cache.interface.ts","../src/interfaces/cache/store.interface.ts","../src/interfaces/cache/repository.interface.ts","../src/interfaces/cache/tagged-cache.interface.ts","../src/interfaces/cache/lock.interface.ts","../src/interfaces/cache/lock-provider.interface.ts","../src/interfaces/cache/cache-manager.interface.ts","../src/interfaces/config/repository-options.interface.ts","../src/interfaces/config/cache.interface.ts","../src/interfaces/config/cache-item.interface.ts","../src/interfaces/config/cache-options.interface.ts","../src/interfaces/config/loader.interface.ts","../src/interfaces/config/decorator-options.interface.ts","../src/interfaces/config/config.interface.ts","../src/interfaces/container/container.interface.ts","../src/interfaces/decorators/class-decorator-options.interface.ts","../src/interfaces/decorators/log-options.interface.ts","../src/interfaces/decorators/validation-function.interface.ts","../src/interfaces/events/event.interface.ts","../src/interfaces/events/listener.interface.ts","../src/interfaces/events/event-bus.interface.ts","../src/interfaces/events/dispatcher.interface.ts","../src/interfaces/events/subscriber.interface.ts","../src/interfaces/queue/queueable.interface.ts","../src/interfaces/queue/should-queue.interface.ts","../src/interfaces/queue/queue-connection.interface.ts","../src/interfaces/queue/queue-manager.interface.ts","../src/interfaces/queue/job-registry.interface.ts","../src/interfaces/queue/worker.interface.ts","../src/interfaces/queue/rate-limit.interface.ts","../src/interfaces/react/app-provider-props.interface.ts","../src/interfaces/react/container-provider-props.interface.ts","../src/interfaces/react/cached-data-result.interface.ts","../src/interfaces/react/cache-value-result.interface.ts","../src/interfaces/console/application.interface.ts","../src/interfaces/console/command.interface.ts","../src/interfaces/console/command-registry.interface.ts","../src/interfaces/console/command-collector.interface.ts","../src/interfaces/console/command-scheduler.interface.ts","../src/interfaces/console/input.interface.ts","../src/interfaces/console/output.interface.ts","../src/interfaces/console/stub-generator.interface.ts","../src/interfaces/console/ask.interface.ts","../src/interfaces/console/table-output.interface.ts","../src/interfaces/console/progress-bar.interface.ts","../src/interfaces/redis/factory.interface.ts","../src/interfaces/redis/connector.interface.ts","../src/interfaces/redis/connection.interface.ts","../src/interfaces/redis/redis.interface.ts","../src/interfaces/routing/controller.interface.ts","../src/interfaces/routing/controller-options.interface.ts","../src/interfaces/routing/route.interface.ts","../src/interfaces/routing/route-options.interface.ts","../src/interfaces/routing/middleware.interface.ts","../src/interfaces/routing/guard.interface.ts","../src/interfaces/routing/param-metadata.interface.ts","../src/interfaces/routing/router-config.interface.ts","../src/interfaces/routing/route-definition.interface.ts","../src/interfaces/routing/controller-definition.interface.ts","../src/enums/config-enviroment.enum.ts","../src/enums/worker-status.enum.ts","../src/enums/param-type.enum.ts","../src/enums/question-type.enum.ts"],"names":["IApplication","IServiceProvider","ICache","IStore","IRepository","ITaggedCache","ILock","ILockProvider","ICacheManager","IConfigRepositoryOptions","IConfigCache","ICacheItem","IConfigCacheOptions","IConfigLoader","IConfigOptions","IConfig","IContainer","IClassDecoratorOptions","ILogOptions","IValidationFunction","IEvent","IListener","IEventBus","IEventDispatcher","ISubscriber","IQueueable","IShouldQueue","IQueueConnection","IQueueManager","IJobRegistry","IWorker","IRateLimiter","IAppProviderProps","IContainerProviderProps","ICachedDataResult","ICacheValueResult","ICommand","ICommandRegistry","ICommandCollector","ICommandScheduler","IInput","IOutput","IStubGenerator","IAsk","ITableOutput","IProgressBar","IRedisFactory","IRedisConnector","IRedisConnection","IRedis","IController","IControllerOptions","IRouteHandler","IRouteOptions","IMiddleware","IGuard","IParamMetadata","IRouterConfig","IRouteDefinition","IControllerDefinition","ConfigEnvironment","WorkerStatus","ParamType","QuestionType"],"mappings":"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","file":"index.mjs","sourcesContent":["import type { interfaces } from 'inversify'\n\nimport { ICache } from '../cache'\nimport { ServiceIdentifier } from '../../types'\nimport type { IContainer } from '../container'\nimport { IConfigRepository } from '../config'\n\n/**\n * Interface for the application\n */\nexport interface IApplication {\n  /**\n   * Get the service container instance.\n   */\n  getContainer(): IContainer\n\n  /**\n   * Register the core service providers.\n   */\n  registerCoreProviders(): IApplication\n\n  /**\n   * Register a service provider.\n   */\n  register(provider: any): IApplication\n\n  /**\n   * Boot the application and all service providers.\n   */\n  boot(): IApplication\n\n  /**\n   * Determine if the application has been bootstrapped.\n   */\n  isBooted(): boolean\n\n  /**\n   * Resolve a service from the container.\n   */\n  make<T>(abstract: ServiceIdentifier<T>): T\n\n  /**\n   * Register a binding with the container.\n   */\n  bind<T>(\n    abstract: ServiceIdentifier<T>,\n    concrete?: any,\n    shared?: boolean,\n  ): IContainer | interfaces.BindingToSyntax<T>\n\n  /**\n   * Register an existing instance in the container.\n   */\n  instance<T>(abstract: ServiceIdentifier<T>, instance: T): IContainer\n\n  /**\n   * Get the configuration repository.\n   */\n  config(): IConfigRepository\n\n  /**\n   * Get the cache manager instance.\n   */\n  cache(): ICache\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IApplication {\n  /**\n   * Symbol for injecting the application service\n   */\n  export const $ = Symbol.for('IApplication')\n}\n","import { IContainer } from '../container'\n\n/**\n * Interface for service providers.\n * Service providers are responsible for binding services into the container\n * and bootstrapping any dependencies.\n *\n * @example\n * \\`\\`\\`typescript\n * class CacheServiceProvider implements IServiceProvider {\n *   protected app: Container;\n *\n *   constructor(app: Container) {\n *     this.app = app;\n *   }\n *\n *   register(): void {\n *     this.app.singleton('cache', () => {\n *       return new CacheManager(this.app);\n *     });\n *   }\n *\n *   boot(): void {\n *     // Bootstrap the cache service\n *   }\n * }\n * \\`\\`\\`\n */ export interface IServiceProvider {\n  /**\n   * The application container instance.\n   */\n  readonly app: IContainer\n\n  /**\n   * Register any application services.\n   */\n  register(): void\n\n  /**\n   * Bootstrap any application services (optional).\n   */\n  boot?(): void\n\n  /**\n   * Clean up services before shutdown (optional).\n   */\n  terminate?(): void\n\n  /**\n   * Publish files or configurations (optional).\n   */\n  publish?(): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IServiceProvider {\n  /**\n   * Symbol for injecting the service provider\n   */\n  export const $ = Symbol.for('IServiceProvider')\n}\n","import type { ILock } from './lock.interface'\n\n/**\n * Interface for the main cache service\n * Provides methods for storing, retrieving, and managing cached data\n */\nexport interface ICache {\n  /**\n   * Get a value from the cache\n   * @param key - The cache key\n   * @param defaultValue - Default value or callback to return if key doesn't exist\n   * @returns The cached value, the default value, or undefined if not found\n   * @template T - The type of value to return\n   */\n  get<T>(key: string, defaultValue?: T): Promise<T | undefined>\n\n  /**\n   * Store a value in the cache\n   * @param key - The cache key\n   * @param value - The value to store\n   * @param ttl - Time to live in seconds (defaults to 60 if not specified)\n   * @returns True if the value was stored successfully\n   * @template T - The type of value being stored\n   */\n  put<T>(key: string, value: T, ttl?: number): Promise<boolean>\n\n  /**\n   * Store a value in the cache indefinitely\n   * @param key - The cache key\n   * @param value - The value to store\n   * @returns True if the value was stored successfully\n   * @template T - The type of value being stored\n   */\n  forever<T>(key: string, value: T): Promise<boolean>\n\n  /**\n   * Remove a value from the cache\n   * @param key - The cache key\n   * @returns True if the value was removed successfully\n   */\n  forget(key: string): Promise<boolean>\n\n  /**\n   * Remove all items from the cache\n   * @returns True if the cache was cleared successfully\n   */\n  flush(): Promise<boolean>\n\n  /**\n   * Get an item from the cache, or store the default value\n   * @param key - The cache key\n   * @param ttl - Time to live in seconds\n   * @param callback - Function that returns the default value\n   * @returns The cached value or the computed default value\n   * @template T - The type of value to return\n   */\n  remember<T>(key: string, ttl: number, callback: () => Promise<T> | T): Promise<T>\n\n  /**\n   * Get an item from the cache, or store the default value forever\n   * @param key - The cache key\n   * @param callback - Function that returns the default value\n   * @returns The cached value or the computed default value\n   * @template T - The type of value to return\n   */\n  rememberForever<T>(key: string, callback: () => Promise<T> | T): Promise<T>\n\n  /**\n   * Increment a value in the cache\n   * @param key - The cache key\n   * @param value - The value to increment by (defaults to 1)\n   * @returns The new value or false if the operation failed\n   */\n  increment(key: string, value?: number): Promise<number | boolean>\n\n  /**\n   * Decrement a value in the cache\n   * @param key - The cache key\n   * @param value - The value to decrement by (defaults to 1)\n   * @returns The new value or false if the operation failed\n   */\n  decrement(key: string, value?: number): Promise<number | boolean>\n\n  /**\n   * Get a lock instance\n   * @param name - The lock name\n   * @param seconds - The lock timeout in seconds (defaults to 60)\n   * @param owner - The lock owner (generated if not provided)\n   * @returns A lock instance\n   */\n  lock(name: string, seconds?: number, owner?: string): ILock\n\n  /**\n   * Get a lock instance without blocking\n   * @param name - The lock name\n   * @param owner - The lock owner\n   * @returns A lock instance\n   */\n  restoreLock(name: string, owner: string): ILock\n\n  /**\n   * Get multiple items from the cache\n   * @param keys - The cache keys\n   * @returns An object mapping keys to values\n   * @template T - The type of values to return\n   */\n  many<T>(keys: string[]): Promise<Record<string, T>>\n\n  /**\n   * Store multiple items in the cache\n   * @param values - The key-value pairs to store\n   * @param ttl - Time to live in seconds (defaults to 60)\n   * @returns True if the values were stored successfully\n   * @template T - The type of values being stored\n   */\n  putMany<T>(values: Record<string, T>, ttl?: number): Promise<boolean>\n\n  /**\n   * Get the cache key prefix\n   * @returns The cache key prefix\n   */\n  getPrefix(): string\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ICache {\n  /**\n   * Symbol for injecting the cache service\n   */\n  export const $ = Symbol.for('ICache')\n}\n","/**\n * Interface for cache store implementations\n * Defines the contract that all cache storage drivers must implement\n */\nimport type { ILockProvider } from './lock-provider.interface'\n\nexport interface IStore {\n  /**\n   * Retrieve an item from the cache by key\n   * @param key - The cache key\n   * @returns The cached value or undefined if not found\n   * @template T - The type of value to return\n   */\n  get<T>(key: string): Promise<T | undefined>\n\n  /**\n   * Store an item in the cache for a given number of seconds\n   * @param key - The cache key\n   * @param value - The value to store\n   * @param seconds - The time to live in seconds (defaults to 60)\n   * @returns True if the value was stored successfully\n   * @template T - The type of value being stored\n   */\n  put<T>(key: string, value: T, seconds?: number): Promise<boolean>\n\n  /**\n   * Store an item in the cache indefinitely\n   * @param key - The cache key\n   * @param value - The value to store\n   * @returns True if the value was stored successfully\n   * @template T - The type of value being stored\n   */\n  forever<T>(key: string, value: T): Promise<boolean>\n\n  /**\n   * Remove an item from the cache\n   * @param key - The cache key\n   * @returns True if the value was removed successfully\n   */\n  forget(key: string): Promise<boolean>\n\n  /**\n   * Remove all items from the cache\n   * @returns True if the cache was cleared successfully\n   */\n  flush(): Promise<boolean>\n\n  /**\n   * Get the cache key prefix\n   * @returns The cache key prefix\n   */\n  getPrefix(): string\n\n  /**\n   * Get multiple items from the cache\n   * @param keys - The cache keys\n   * @returns An object mapping keys to values\n   * @template T - The type of values to return\n   */\n  many<T>(keys: string[]): Promise<Record<string, T>>\n\n  /**\n   * Store multiple items in the cache\n   * @param values - The key-value pairs to store\n   * @param seconds - The time to live in seconds (defaults to 60)\n   * @returns True if the values were stored successfully\n   * @template T - The type of values being stored\n   */\n  putMany<T>(values: Record<string, T>, seconds?: number): Promise<boolean>\n\n  /**\n   * Increment the value of an item in the cache\n   * @param key - The cache key\n   * @param value - The value to increment by (defaults to 1)\n   * @returns The new value or false if the operation failed\n   */\n  increment(key: string, value?: number): Promise<number | boolean>\n\n  /**\n   * Decrement the value of an item in the cache\n   * @param key - The cache key\n   * @param value - The value to decrement by (defaults to 1)\n   * @returns The new value or false if the operation failed\n   */\n  decrement(key: string, value?: number): Promise<number | boolean>\n\n  /**\n   * Get the lock provider\n   * @returns The lock provider instance\n   */\n  getLockProvider(): ILockProvider\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IStore {\n  /**\n   * Symbol for injecting the store service\n   */\n  export const $ = Symbol.for('IStore')\n\n  /**\n   * Symbol for injecting the array store\n   */\n  export const ArrayStore = Symbol.for('ArrayStore')\n\n  /**\n   * Symbol for injecting the file store\n   */\n  export const FileStore = Symbol.for('FileStore')\n\n  /**\n   * Symbol for injecting the memcached store\n   */\n  export const MemcachedStore = Symbol.for('MemcachedStore')\n\n  /**\n   * Symbol for injecting the redis store\n   */\n  export const RedisStore = Symbol.for('RedisStore')\n\n  /**\n   * Symbol for injecting the dynamodb store\n   */\n  export const DynamoDbStore = Symbol.for('DynamoDbStore')\n\n  /**\n   * Symbol for injecting the database store\n   */\n  export const DatabaseStore = Symbol.for('DatabaseStore')\n\n  /**\n   * Symbol for injecting the null store\n   */\n  export const NullStore = Symbol.for('NullStore')\n}\n","import type { ICache } from './cache.interface'\nimport type { ITaggedCache } from './tagged-cache.interface'\n\n/**\n * Interface for the cache repository\n * Extends the ICache interface with tagging capabilities\n * The repository acts as a higher-level abstraction over the cache store\n */\nexport interface IRepository extends ICache {\n  /**\n   * Get a tagged cache instance\n   * Tagged caches allow grouping cache items and invalidating them together\n   *\n   * @param tags - The cache tags (single tag or array of tags)\n   * @returns A tagged cache instance\n   */\n  tags(tags: string | string[]): ITaggedCache\n\n  /**\n   * Get the underlying cache store\n   * Provides access to the store implementation for advanced operations\n   *\n   * @returns The cache store implementation\n   */\n  getStore(): any\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IRepository {\n  /**\n   * Symbol for injecting the repository service\n   */\n  export const $ = Symbol.for('IRepository')\n}\n","import type { ICache } from './cache.interface'\n\n/**\n * Interface for tagged cache\n * Tagged caches allow grouping cache items and invalidating them together\n * This is useful for cache invalidation strategies where multiple related\n * cache entries need to be invalidated at once\n */\nexport interface ITaggedCache extends ICache {\n  /**\n   * Get the tag names\n   * Returns the array of tags associated with this cache instance\n   *\n   * @returns The array of tag names\n   */\n  getTags(): string[]\n\n  /**\n   * Reset all tags\n   * This generates new tag IDs for all tags, effectively invalidating\n   * all cache entries associated with these tags\n   */\n  resetTags(): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ITaggedCache {\n  /**\n   * Symbol for injecting the tagged cache service\n   */\n  export const $ = Symbol.for('ITaggedCache')\n}\n","/**\n * Interface for cache locks\n * Provides methods for distributed locking to coordinate access to shared resources\n */\nexport interface ILock {\n  /**\n   * Attempt to acquire the lock\n   * If the lock is acquired, the callback is executed and the lock is released afterward\n   * If the lock cannot be acquired, an error is thrown\n   *\n   * @param callback - The callback to execute if the lock is acquired\n   * @returns The result of the callback\n   * @template T - The type of value returned by the callback\n   * @throws Error if the lock cannot be acquired\n   */\n  get<T>(callback: () => Promise<T> | T): Promise<T>\n\n  /**\n   * Attempt to acquire the lock for the given number of seconds\n   * This method will retry acquiring the lock until the timeout is reached\n   *\n   * @param seconds - The maximum time to wait for the lock in seconds\n   * @param callback - The callback to execute if the lock is acquired\n   * @returns The result of the callback\n   * @template T - The type of value returned by the callback\n   * @throws Error if the lock cannot be acquired within the timeout\n   */\n  block<T>(seconds: number, callback: () => Promise<T> | T): Promise<T>\n\n  /**\n   * Release the lock\n   * This will only succeed if the current instance is the owner of the lock\n   *\n   * @returns True if the lock was released successfully\n   */\n  release(): Promise<boolean>\n\n  /**\n   * Returns the owner value written to the driver for this lock\n   * The owner is a unique identifier for the lock instance\n   *\n   * @returns The lock owner string\n   */\n  owner(): string\n\n  /**\n   * Releases this lock in disregard of ownership\n   * This is a forceful operation that should be used with caution\n   *\n   * @returns True if the lock was released successfully\n   */\n  forceRelease(): Promise<boolean>\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ILock {\n  /**\n   * Symbol for injecting the lock service\n   */\n  export const $ = Symbol.for('ILock')\n}\n","import type { ILock } from './lock.interface'\n\n/**\n * Interface for lock providers\n * Lock providers are responsible for creating lock instances\n * Each cache store has its own lock provider implementation\n */\nexport interface ILockProvider {\n  /**\n   * Get a lock instance\n   * Creates a new lock with the specified name, timeout, and owner\n   *\n   * @param name - The lock name (unique identifier for the resource being locked)\n   * @param seconds - The lock timeout in seconds (defaults to 60)\n   * @param owner - The lock owner (generated if not provided)\n   * @returns A lock instance\n   */\n  lock(name: string, seconds?: number, owner?: string): ILock\n\n  /**\n   * Restore a lock instance\n   * Creates a lock instance with a specific owner, used to manage an existing lock\n   *\n   * @param name - The lock name\n   * @param owner - The lock owner\n   * @returns A lock instance\n   */\n  restoreLock(name: string, owner: string): ILock\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ILockProvider {\n  /**\n   * Symbol for injecting the lock provider service\n   */\n  export const $ = Symbol.for('ILockProvider')\n}\n","import type { IStore } from './store.interface'\nimport type { IRepository } from './repository.interface'\n\n/**\n * Interface for the cache manager\n * The cache manager is responsible for creating and managing cache stores\n * It acts as a factory for cache repositories\n */\nexport interface ICacheManager {\n  /**\n   * Get the default cache store name\n   * @returns The name of the default cache store\n   */\n  getDefaultInstance(): string\n\n  /**\n   * Set the default cache store name\n   * @param name - The store name to set as default\n   */\n  setDefaultInstance(name: string): void\n\n  /**\n   * Get the cache store configuration\n   * @param name - The store name\n   * @returns The store configuration object, or null if not found\n   */\n  getInstanceConfig(name: string): Record<string, any> | null\n\n  /**\n   * Create a new cache repository with the given implementation\n   * @param store - The cache store implementation\n   * @returns A repository instance wrapping the store\n   */\n  repository(store: IStore): IRepository\n\n  /**\n   * Get a cache store instance\n   * @param name - The store name (optional, uses default if not provided)\n   * @returns A repository instance for the requested store\n   */\n  store(name?: string): IRepository\n\n  /**\n   * Get the default cache driver name\n   * This is an alias for getDefaultInstance for compatibility with Laravel-style managers\n   * @returns The name of the default cache store\n   */\n  getDefaultDriver(): string\n\n  /**\n   * Set the default cache driver name\n   * This is an alias for setDefaultInstance for compatibility with Laravel-style managers\n   * @param name - The driver name to set as default\n   */\n  setDefaultDriver(name: string): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ICacheManager {\n  /**\n   * Symbol for injecting the cache manager service\n   */\n  export const $ = Symbol.for('ICacheManager')\n}\n","import type { IConfigSchema } from './schema.interface'\nimport type { IConfigCacheOptions } from './cache-options.interface'\n\n/**\n * Configuration repository options\n * Controls the behavior of the configuration repository\n */\nexport interface IConfigRepositoryOptions {\n  /**\n   * Initial configuration items\n   */\n  items?: Record<string, any>\n\n  /**\n   * Environment variable prefix\n   * @default \"APP_\"\n   */\n  envPrefix?: string\n\n  /**\n   * Cache options\n   * @default { enabled: true }\n   */\n  cache?: boolean | IConfigCacheOptions\n\n  /**\n   * Configuration schemas for validation\n   */\n  schemas?: Record<string, IConfigSchema>\n\n  /**\n   * Whether to validate configuration values\n   * @default false\n   */\n  validate?: boolean\n\n  /**\n   * Configuration sources to load from\n   * Can be file paths, URLs, or other source identifiers\n   */\n  sources?: string[]\n\n  /**\n   * Whether to watch for changes in configuration sources\n   * @default false\n   */\n  watch?: boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IConfigRepositoryOptions {\n  /**\n   * Symbol for injecting the config repository options service\n   */\n  export const $ = Symbol.for('IConfigRepositoryOptions')\n}\n","/**\n * Interface for the configuration cache\n */\nexport interface IConfigCache {\n  /**\n   * Enable or disable the cache\n   *\n   * @param enabled - Whether to enable the cache\n   */\n  setEnabled(enabled: boolean): void\n\n  /**\n   * Set the maximum cache size\n   *\n   * @param maxSize - The maximum number of items to store in the cache\n   */\n  setMaxSize(maxSize: number): void\n\n  /**\n   * Set the time to live for cache items\n   *\n   * @param ttl - The time to live in milliseconds\n   */\n  setTtl(ttl: number): void\n\n  /**\n   * Get a value from the cache\n   *\n   * @param key - The cache key\n   */\n  get<T>(key: string): T | undefined\n\n  /**\n   * Set a value in the cache\n   *\n   * @param key - The cache key\n   * @param value - The value to cache\n   */\n  set<T>(key: string, value: T): void\n\n  /**\n   * Delete a value from the cache\n   *\n   * @param key - The cache key\n   */\n  delete(key: string): void\n\n  /**\n   * Clear the cache\n   */\n  clear(): void\n\n  /**\n   * Get the number of items in the cache\n   */\n  size(): number\n\n  /**\n   * Check if a key exists in the cache\n   *\n   * @param key - The cache key\n   */\n  has(key: string): boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IConfigCache {\n  /**\n   * Symbol for injecting the config cache service\n   */\n  export const $ = Symbol.for('IConfigCache')\n}\n","/**\n * Cache item interface\n * Represents a single cached configuration value\n */\nexport interface ICacheItem<T> {\n  /**\n   * The cached value\n   */\n  value: T\n\n  /**\n   * The expiration timestamp (milliseconds since epoch)\n   * If undefined, the item never expires\n   */\n  expires?: number\n\n  /**\n   * When the item was created (milliseconds since epoch)\n   */\n  created: number\n\n  /**\n   * When the item was last accessed (milliseconds since epoch)\n   */\n  lastAccessed?: number\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ICacheItem {\n  /**\n   * Symbol for injecting the cache item service\n   */\n  export const $ = Symbol.for('ICacheItem')\n}\n","/**\n * Configuration cache options\n * Controls how configuration values are cached\n */\nexport interface IConfigCacheOptions {\n  /**\n   * Whether the cache is enabled\n   * @default true\n   */\n  enabled?: boolean\n\n  /**\n   * The maximum number of items to store in the cache\n   * @default 1000\n   */\n  maxSize?: number\n\n  /**\n   * The time to live for cache items in milliseconds\n   * @default 0 (no expiration)\n   */\n  ttl?: number\n\n  /**\n   * Whether to use a persistent cache\n   * @default false\n   */\n  persistent?: boolean\n\n  /**\n   * The storage key for persistent cache\n   * @default \"config_cache\"\n   */\n  storageKey?: string\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IConfigCacheOptions {\n  /**\n   * Symbol for injecting the config cache options service\n   */\n  export const $ = Symbol.for('IConfigCacheOptions')\n}\n","/**\n * Configuration loader interface\n * Responsible for loading configuration from various sources\n */\nexport interface IConfigLoader {\n  /**\n   * Load configuration from a source\n   *\n   * @param source - The source to load from (file path, URL, etc.)\n   * @returns A promise resolving to the loaded configuration\n   */\n  load(source: string): Promise<Record<string, any>>\n\n  /**\n   * Check if the loader can load from a source\n   *\n   * @param source - The source to check\n   * @returns Whether the loader can load from the source\n   */\n  canLoad(source: string): boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IConfigLoader {\n  /**\n   * Symbol for injecting the config loader service\n   */\n  export const $ = Symbol.for('IConfigLoader')\n}\n","/**\n * Options for the Config decorator\n * Controls how configuration values are injected into class properties\n */\nexport interface IConfigOptions {\n  /**\n   * The configuration key to retrieve\n   */\n  key: string\n\n  /**\n   * The default value to use if the configuration key doesn't exist\n   */\n  defaultValue?: any\n\n  /**\n   * The enviroment variables\n   */\n  env?: string\n\n  /**\n   * Whether to refresh the value when accessed\n   * When true, the value is retrieved from the config repository each time\n   * @default false\n   */\n  refresh?: boolean\n\n  /**\n   * Transform function to apply to the value\n   * Allows custom formatting or type conversion\n   */\n  transform?: (value: any) => any\n\n  /**\n   * Whether to validate the value against its schema\n   * @default true\n   */\n  validate?: boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IConfigOptions {\n  /**\n   * Symbol for injecting the config options service\n   */\n  export const $ = Symbol.for('IConfigOptions')\n}\n","import { IConfigRepository } from './repository.interface'\n\n/**\n * Interface for the configuration repository\n */\nexport interface IConfig extends IConfigRepository {}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IConfig {\n  /**\n   * Symbol for injecting the cache manager service\n   */\n  export const $ = Symbol.for('IConfig')\n}\n","import type { Container as InversifyContainer, interfaces } from 'inversify'\n\nimport type { IContextualBindingBuilder } from './contextual-binding-builder.interface'\nimport type { IServiceProvider } from '../application'\nimport { ServiceIdentifier } from '../../types'\n\n/**\n * Interface for the service container.\n */\nexport interface IContainer {\n  /**\n   * Get the underlying Inversify container.\n   *\n   * @returns The Inversify container\n   */\n  getInversifyContainer(): InversifyContainer\n\n  /**\n   * Determine if the given abstract type has been bound.\n   *\n   * @param abstract - The abstract type to check\n   * @returns True if the abstract type has been bound, false otherwise\n   */\n  has(abstract: ServiceIdentifier): boolean\n\n  /**\n   * Load container modules.\n   *\n   * @param modules - The container modules to load\n   * @returns The container instance\n   */\n  load(...modules: interfaces.ContainerModule[]): IContainer\n\n  /**\n   * Load container modules asynchronously.\n   *\n   * @param modules - The container modules to load\n   */\n  loadAsync(...modules: interfaces.AsyncContainerModule[]): Promise<IContainer>\n\n  /**\n   * Unload container modules.\n   *\n   * @param modules - The container modules to unload\n   * @returns The container instance\n   */\n  unload(...modules: interfaces.ContainerModuleBase[]): IContainer\n\n  /**\n   * Unload container modules asynchronously.\n   *\n   * @param modules - The container modules to unload\n   */\n  unloadAsync(...modules: interfaces.ContainerModuleBase[]): Promise<IContainer>\n\n  /**\n   * Register a binding with the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   * @param shared - Whether the binding should be shared\n   */\n  bind<T>(\n    abstract: string | ServiceIdentifier<T>,\n    concrete?: any,\n    shared?: boolean,\n  ): IContainer | interfaces.BindingToSyntax<T>\n\n  /**\n   * Rebind a service identifier.\n   *\n   * @param serviceIdentifier - The service identifier to rebind\n   * @returns The binding syntax\n   */\n  rebind<T>(serviceIdentifier: ServiceIdentifier<T>): interfaces.BindingToSyntax<T>\n\n  /**\n   * Rebind a service identifier asynchronously.\n   *\n   * @param serviceIdentifier - The service identifier to rebind\n   */\n  rebindAsync<T>(serviceIdentifier: ServiceIdentifier<T>): Promise<interfaces.BindingToSyntax<T>>\n\n  /**\n   * Unbind a service identifier.\n   *\n   * @param serviceIdentifier - The service identifier to unbind\n   */\n  unbind(serviceIdentifier: ServiceIdentifier<any>): void\n\n  /**\n   * Unbind a service identifier asynchronously.\n   *\n   * @param serviceIdentifier - The service identifier to unbind\n   * @returns A promise that resolves when the unbinding is complete\n   */\n  unbindAsync(serviceIdentifier: ServiceIdentifier<any>): Promise<void>\n\n  /**\n   * Unbind all bindings.\n   */\n  unbindAll(): void\n\n  /**\n   * Unbind all bindings asynchronously.\n   *\n   * @returns A promise that resolves when all unbindings are complete\n   */\n  unbindAllAsync(): Promise<void>\n\n  /**\n   * Unbind a tagged binding.\n   *\n   * @param serviceIdentifier - The service identifier\n   * @param key - The tag key\n   * @param value - The tag value\n   */\n  unbindTagged<T>(serviceIdentifier: ServiceIdentifier<T>, key: string, value: any): void\n\n  /**\n   * Register a binding with a tag.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @param shared - Whether the binding should be shared\n   */\n  bindTagged(\n    abstract: ServiceIdentifier,\n    concrete: any,\n    tag: string,\n    value: any,\n    shared?: boolean,\n  ): IContainer\n\n  /**\n   * Register a shared binding in the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param concrete - The concrete implementation\n   * @returns The container instance\n   */\n  singleton<T>(abstract: ServiceIdentifier<T>, concrete: any): IContainer\n\n  /**\n   * Register an existing instance as shared in the container.\n   *\n   * @param abstract - The abstract type to bind\n   * @param instance - The instance to register\n   * @returns The container instance\n   */\n  instance<T>(abstract: ServiceIdentifier<T>, instance: T): IContainer\n\n  /**\n   * Alias a type to a different name.\n   *\n   * @param abstract - The abstract type to alias\n   * @param alias - The alias identifier\n   * @returns The container instance\n   */\n  alias<T>(abstract: ServiceIdentifier<T>, alias: ServiceIdentifier<T>): IContainer\n\n  /**\n   * Apply middleware to the container.\n   *\n   * @param middlewares - The middleware to apply\n   * @returns The container instance\n   */\n  applyMiddleware(...middlewares: interfaces.Middleware[]): IContainer\n\n  /**\n   * Apply a custom metadata reader to the container.\n   *\n   * @param metadataReader - The metadata reader to apply\n   * @returns The container instance\n   */\n  applyCustomMetadataReader(metadataReader: interfaces.MetadataReader): IContainer\n\n  /**\n   * Define a contextual binding.\n   *\n   * @param concrete - The concrete implementation that needs a dependency\n   * @returns A builder for defining the contextual binding\n   */\n  when(concrete: string | Function): IContextualBindingBuilder\n\n  /**\n   * Register a contextual binding in the container.\n   *\n   * @param concrete - The concrete implementation that needs a dependency\n   * @param abstract - The abstract type that the concrete implementation needs\n   * @param tag - The tag for the binding\n   * @returns The container instance\n   * @internal\n   */\n  registerContextualBinding(concrete: string, abstract: ServiceIdentifier, tag: string): IContainer\n\n  /**\n   * Register an activation handler for a service.\n   *\n   * @param serviceIdentifier - The service identifier\n   * @param onActivation - The activation handler\n   */\n  onActivation<T>(\n    serviceIdentifier: ServiceIdentifier<T>,\n    onActivation: interfaces.BindingActivation<T>,\n  ): void\n\n  /**\n   * Register a deactivation handler for a service.\n   *\n   * @param serviceIdentifier - The service identifier\n   * @param onDeactivation - The deactivation handler\n   */\n  onDeactivation<T>(\n    serviceIdentifier: ServiceIdentifier<T>,\n    onDeactivation: interfaces.BindingDeactivation<T>,\n  ): void\n\n  /**\n   * Check if a service identifier is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @returns True if the service identifier is bound, false otherwise\n   */\n  isBound(serviceIdentifier: ServiceIdentifier<unknown>): boolean\n\n  /**\n   * Check if a service identifier is bound in the current container (not in ancestors).\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @returns True if the service identifier is bound in the current container, false otherwise\n   */\n  isCurrentBound<T>(serviceIdentifier: ServiceIdentifier<T>): boolean\n\n  /**\n   * Check if a named binding is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @param named - The name to check\n   * @returns True if the named binding is bound, false otherwise\n   */\n  isBoundNamed(serviceIdentifier: ServiceIdentifier<any>, named: string | number | symbol): boolean\n\n  /**\n   * Check if a tagged binding is bound.\n   *\n   * @param serviceIdentifier - The service identifier to check\n   * @param key - The tag key\n   * @param value - The tag value\n   * @returns True if the tagged binding is bound, false otherwise\n   */\n  isBoundTagged(\n    serviceIdentifier: ServiceIdentifier<any>,\n    key: string | number | symbol,\n    value: unknown,\n  ): boolean\n\n  /**\n   * Create a snapshot of the container's state.\n   */\n  snapshot(): void\n\n  /**\n   * Restore the container's state from a snapshot.\n   */\n  restore(): void\n\n  /**\n   * Create a child container.\n   *\n   * @param containerOptions - The container options\n   * @returns A new child container\n   */\n  createChild(containerOptions?: interfaces.ContainerOptions): IContainer\n\n  /**\n   * Resolve the given type from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param parameters - Optional parameters to pass to the constructor\n   */\n  make<T>(abstract: ServiceIdentifier<T>, parameters?: any[]): T\n\n  /**\n   * Resolve the given type from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @returns A promise that resolves to the resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeAsync<T>(abstract: ServiceIdentifier<T>): Promise<T>\n\n  /**\n   * Resolve a tagged binding from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @returns The resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeTagged<T>(abstract: ServiceIdentifier<T>, tag: string, value: any): T\n\n  /**\n   * Resolve a tagged binding from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @returns A promise that resolves to the resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeTaggedAsync<T>(abstract: ServiceIdentifier<T>, tag: string, value: any): Promise<T>\n\n  /**\n   * Resolve a named binding from the container.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   * @returns The resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeNamed<T>(abstract: ServiceIdentifier<T>, named: string | number | symbol): T\n\n  /**\n   * Resolve a named binding from the container asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   * @returns A promise that resolves to the resolved instance\n   * @template T - The type of the resolved instance\n   */\n  makeNamedAsync<T>(abstract: ServiceIdentifier<T>, named: string | number | symbol): Promise<T>\n\n  /**\n   * Resolve all bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   * @returns All resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAll<T>(abstract: ServiceIdentifier<T>): T[]\n\n  /**\n   * Resolve all bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @returns A promise that resolves to all resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllAsync<T>(abstract: ServiceIdentifier<T>): Promise<T[]>\n\n  /**\n   * Resolve all tagged bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @returns All resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllTagged<T>(abstract: ServiceIdentifier<T>, tag: string, value: any): T[]\n\n  /**\n   * Resolve all tagged bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param tag - The tag name\n   * @param value - The tag value\n   * @returns A promise that resolves to all resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllTaggedAsync<T>(abstract: ServiceIdentifier<T>, tag: string, value: any): Promise<T[]>\n\n  /**\n   * Resolve all named bindings for a service identifier.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   * @returns All resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllNamed<T>(abstract: ServiceIdentifier<T>, named: string | number | symbol): T[]\n\n  /**\n   * Resolve all named bindings for a service identifier asynchronously.\n   *\n   * @param abstract - The abstract type to resolve\n   * @param named - The name\n   * @returns A promise that resolves to all resolved instances\n   * @template T - The type of the resolved instances\n   */\n  makeAllNamedAsync<T>(\n    abstract: ServiceIdentifier<T>,\n    named: string | number | symbol,\n  ): Promise<T[]>\n\n  /**\n   * Resolve a class constructor.\n   *\n   * @param constructorFunction - The constructor function to resolve\n   * @returns The resolved instance\n   * @template T - The type of the resolved instance\n   */\n  resolve<T>(constructorFunction: interfaces.Newable<T>): T\n\n  /**\n   * Register a service provider with the container.\n   *\n   * @param provider - The service provider to register\n   * @returns The container instance\n   */\n  register(provider: IServiceProvider): IContainer\n\n  /**\n   * Boot the registered service providers.\n   *\n   * @returns The container instance\n   */\n  boot(): IContainer\n\n  /**\n   * Call the given callback with the container instance.\n   *\n   * @param callback - The callback to call\n   * @returns The result of the callback\n   * @template T - The return type of the callback\n   */\n  call<T>(callback: (container: IContainer) => T): T\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IContainer {\n  /**\n   * Symbol for injecting the container service\n   */\n  export const $ = Symbol.for('IContainer')\n}\n","/**\n * Options for creating a class decorator\n * Controls how the decorator modifies the target class\n */\nexport interface IClassDecoratorOptions {\n  /**\n   * Whether to copy prototype properties\n   * @default true\n   */\n  copyPrototype?: boolean\n\n  /**\n   * Whether to copy static properties\n   * @default true\n   */\n  copyStatic?: boolean\n\n  /**\n   * Whether to copy metadata\n   * @default true\n   */\n  copyMetadata?: boolean\n\n  /**\n   * A function to run before the constructor is called\n   * Can be used to prepare the environment or validate arguments\n   */\n  beforeConstructor?: (target: any, args: any[]) => void\n\n  /**\n   * A function to run after the constructor is called\n   * Can be used to modify the created instance\n   */\n  afterConstructor?: (instance: any, target: any, args: any[]) => void\n\n  /**\n   * A function to transform the instance after creation\n   * Can return a completely different object\n   */\n  transformInstance?: (instance: any, target: any, args: any[]) => any\n\n  /**\n   * Whether to inherit parent class decorators\n   * @default true\n   */\n  inheritDecorators?: boolean\n\n  /**\n   * Whether to seal the resulting class\n   * @default false\n   */\n  seal?: boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IClassDecoratorOptions {\n  /**\n   * Symbol for injecting the class decorator options service\n   */\n  export const $ = Symbol.for('IClassDecoratorOptions')\n}\n","/**\n * Log decorator options\n * Controls how method calls are logged\n */\nexport interface ILogOptions {\n  /**\n   * The log level\n   * @default \"info\"\n   */\n  level?: 'debug' | 'info' | 'warn' | 'error'\n\n  /**\n   * Whether to log method arguments\n   * @default true\n   */\n  logArgs?: boolean\n\n  /**\n   * Whether to log method return values\n   * @default true\n   */\n  logReturn?: boolean\n\n  /**\n   * Whether to log execution time\n   * @default true\n   */\n  logTime?: boolean\n\n  /**\n   * Custom logger to use\n   * If not provided, console is used\n   */\n  logger?: any\n\n  /**\n   * Whether to log errors\n   * @default true\n   */\n  logErrors?: boolean\n\n  /**\n   * Custom message format\n   * Available placeholders: {className}, {methodName}, {args}, {result}, {time}\n   */\n  format?: string\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ILogOptions {\n  /**\n   * Symbol for injecting the log options service\n   */\n  export const $ = Symbol.for('ILogOptions')\n}\n","import type { ValidationArguments } from 'class-validator'\n\n/**\n * Interface for validation function\n * Used for custom validation rules\n */\nexport interface IValidationFunction {\n  /**\n   * Validate a value\n   *\n   * @param value - The value to validate\n   * @param args - The validation arguments\n   * @returns Whether the value is valid or a promise that resolves to whether the value is valid\n   */\n  (value: any, args: ValidationArguments): boolean | Promise<boolean>\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IValidationFunction {\n  /**\n   * Symbol for injecting the validation function service\n   */\n  export const $ = Symbol.for('IValidationFunction')\n}\n","/**\n * Interface for all events in the system.\n * Events are objects that represent something that has happened in the application.\n * They can be dispatched and listened to by event listeners.\n */\nexport interface IEvent {\n  /**\n   * Optional method to get the event name.\n   * If not provided, the class name will be used.\n   */\n  getEventName?(): string\n\n  /**\n   * Optional method to determine if the event should be broadcast.\n   * @returns {boolean} Whether the event should be broadcast\n   */\n  shouldBroadcast?(): boolean\n\n  /**\n   * Optional method to get the channels the event should broadcast on.\n   * @returns {string[]} Array of channel names\n   */\n  broadcastOn?(): string[]\n\n  /**\n   * Optional method to get the broadcast data.\n   * @returns {Record<string, any>} Data to broadcast\n   */\n  broadcastWith?(): Record<string, any>\n}\n\n/**\n * DI token for IEvent interface\n */\nexport namespace IEvent {\n  export const $ = Symbol.for('IEvent')\n}\n","import type { IEvent } from './event.interface'\n\n/**\n * Interface for all event listeners in the system.\n * Listeners are responsible for handling events when they are dispatched.\n */\nexport interface IListener<E extends IEvent = IEvent> {\n  /**\n   * Handle the event.\n   * This method is called when the event is dispatched.\n   *\n   * @param {E} event - The event object\n   * @returns {Promise<void> | void} - May return a promise for async handling\n   */\n  handle(event: E): Promise<void> | void\n}\n\n/**\n * DI token for IListener interface\n */\nexport namespace IListener {\n  export const $ = Symbol.for('IListener')\n}\n","import type { Observable } from 'rxjs'\nimport type { IEvent } from './event.interface'\nimport type { IEventData } from './event-data.interface'\n\n/**\n * Interface for the event bus\n * The event bus provides a centralized mechanism for dispatching and subscribing to events\n */\nexport interface IEventBus {\n  /**\n   * Get an observable of all events\n   *\n   * @returns An observable of all events\n   */\n  events(): Observable<IEventData>\n\n  /**\n   * Get an observable of events with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of events with the specified name\n   */\n  ofType(eventName: string): Observable<IEventData>\n\n  /**\n   * Get an observable of events of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of events of the specified class\n   */\n  ofClass<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<IEventData<T>>\n\n  /**\n   * Get an observable of event payloads with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of event payloads with the specified name\n   */\n  on<T = any>(eventName: string): Observable<T>\n\n  /**\n   * Get an observable of event payloads of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of event payloads of the specified class\n   */\n  onEvent<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<T>\n\n  /**\n   * Dispatch an event through the event bus\n   *\n   * @param event - The event to dispatch\n   * @param payload - Optional payload if event is a string\n   * @returns A promise that resolves when the event has been dispatched\n   */\n  dispatch(event: string | IEvent, payload?: any): Promise<any[]>\n\n  /**\n   * Register a callback for a specific event\n   *\n   * @param eventName - The event name\n   * @param callback - The callback function\n   * @returns A function to unregister the callback\n   */\n  subscribe<T = any>(eventName: string, callback: (data: T) => void): () => void\n\n  /**\n   * Register a callback for a specific event class\n   *\n   * @param eventClass - The event class\n   * @param callback - The callback function\n   * @returns A function to unregister the callback\n   */\n  subscribeToEvent<T extends IEvent>(\n    eventClass: new (...args: any[]) => T,\n    callback: (event: T) => void,\n  ): () => void\n}\n\n/**\n * DI token for IEventBus interface\n */\nexport namespace IEventBus {\n  export const $ = Symbol.for('IEventBus')\n}\n","import type { Observable } from 'rxjs'\nimport type { IEvent } from './event.interface'\nimport type { IListener } from './listener.interface'\nimport type { ISubscriber } from './subscriber.interface'\nimport type { IEventData } from './event-data.interface'\n\n/**\n * Interface for the event dispatcher.\n * The dispatcher is responsible for registering listeners and dispatching events.\n */\nexport interface IEventDispatcher {\n  /**\n   * Register an event listener with the dispatcher.\n   *\n   * @param {string} event - The event name\n   * @param {IListener | Function} listener - The listener function or object\n   * @returns {() => void} A function to remove the listener\n   */\n  listen(event: string, listener: IListener | Function): () => void\n\n  /**\n   * Determine if a given event has listeners.\n   *\n   * @param {string} eventName - The event name\n   * @returns {boolean} True if the event has listeners\n   */\n  hasListeners(eventName: string): boolean\n\n  /**\n   * Register an event subscriber with the dispatcher.\n   *\n   * @param {ISubscriber} subscriber - The subscriber to register\n   */\n  subscribe(subscriber: ISubscriber): void\n\n  /**\n   * Dispatch an event and call the listeners.\n   *\n   * @param {string | IEvent} event - The event name or object\n   * @param {any} [payload] - The event payload (if event is a string)\n   * @returns {Promise<any[]>} Array of results from the listeners\n   */\n  dispatch(event: string | IEvent, payload?: any): Promise<any[]>\n\n  /**\n   * Dispatch an event and halt when the first listener returns a non-null response.\n   *\n   * @param {string | IEvent} event - The event name or object\n   * @param {any} [payload] - The event payload (if event is a string)\n   * @returns {Promise<any>} The first non-null response or null\n   */\n  until(event: string | IEvent, payload?: any): Promise<any>\n\n  /**\n   * Remove a set of listeners from the dispatcher.\n   *\n   * @param {string} event - The event name\n   */\n  forget(event: string): void\n\n  /**\n   * Remove all listeners from the dispatcher.\n   */\n  forgetAll(): void\n\n  /**\n   * Get an observable of all events\n   *\n   * @returns An observable of all events\n   */\n  events(): Observable<IEventData>\n\n  /**\n   * Get an observable of events with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of events with the specified name\n   */\n  ofType(eventName: string): Observable<IEventData>\n\n  /**\n   * Get an observable of events of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of events of the specified class\n   */\n  ofClass<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<IEventData<T>>\n\n  /**\n   * Get an observable of event payloads with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of event payloads with the specified name\n   */\n  on<T = any>(eventName: string): Observable<T>\n\n  /**\n   * Get an observable of event payloads of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of event payloads of the specified class\n   */\n  onEvent<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<T>\n\n  /**\n   * Get the number of listeners for a specific event\n   *\n   * @param eventName - The event name\n   * @returns The number of listeners\n   */\n  listenerCount(eventName: string): number\n}\n\n/**\n * DI token for IEventDispatcher interface\n */\nexport namespace IEventDispatcher {\n  export const $ = Symbol.for('IEventDispatcher')\n}\n","import type { IEventDispatcher } from './dispatcher.interface'\n\n/**\n * Interface for event subscribers.\n * Subscribers can listen to multiple events and register multiple listeners.\n */\nexport interface ISubscriber {\n  /**\n   * Register the listeners for the subscriber.\n   * This method is called when the subscriber is registered with the dispatcher.\n   *\n   * @param {IEventDispatcher} dispatcher - The event dispatcher\n   */\n  subscribe(dispatcher: IEventDispatcher): void\n}\n\n/**\n * DI token for ISubscriber interface\n */\nexport namespace ISubscriber {\n  export const $ = Symbol.for('ISubscriber')\n}\n","import type { IShouldQueue } from './should-queue.interface'\n\n/**\n * Interface for queueable jobs.\n * Queueable items can be processed asynchronously through a queue.\n */\nexport interface IQueueable extends IShouldQueue {\n  /**\n   * Handle the job.\n   *\n   * @param data - The job data\n   * @returns Promise resolving when the job is complete\n   */\n  handle(data: any): Promise<void>\n\n  /**\n   * Get the middleware the job should pass through.\n   *\n   * @returns Array of middleware names\n   */\n  middleware?(): string[]\n\n  /**\n   * Determine if the job should be encrypted.\n   *\n   * @returns True if the job should be encrypted\n   */\n  shouldBeEncrypted?(): boolean\n\n  /**\n   * The number of times the job may be attempted.\n   *\n   * @returns The maximum number of attempts\n   */\n  tries?(): number\n\n  /**\n   * The number of seconds the job can run before timing out.\n   *\n   * @returns The timeout in seconds\n   */\n  timeout?(): number\n\n  /**\n   * Calculate the number of seconds to wait before retrying the job.\n   *\n   * @param attempt - The current attempt number\n   * @returns The number of seconds to wait\n   */\n  retryAfter?(attempt: number): number\n\n  /**\n   * Determine if the job should be released back onto the queue.\n   *\n   * @param error - The error that caused the job to fail\n   * @returns True if the job should be released\n   */\n  shouldRelease?(error: Error): boolean\n\n  /**\n   * Handle a job failure.\n   *\n   * @param error - The error that caused the job to fail\n   * @returns Promise resolving when the failure is handled\n   */\n  failed?(error: Error): Promise<void>\n\n  /**\n   * Report progress of the job.\n   *\n   * @param progress - The progress percentage (0-100)\n   * @param data - Additional progress data\n   */\n  reportProgress?(progress: number, data?: any): Promise<void>\n}\n\n/**\n * DI token for IQueueable interface\n */\nexport namespace IQueueable {\n  export const $ = Symbol.for('IQueueable')\n}\n","/**\n * Interface for objects that can be queued.\n * Implementing this interface indicates that the object should be processed asynchronously.\n */\nexport interface IShouldQueue {\n  /**\n   * Determine if the object should be queued.\n   *\n   * @returns {boolean} True if the object should be queued\n   */\n  shouldQueue(): boolean\n\n  /**\n   * Get the connection the job should be sent to.\n   *\n   * @returns {string|null} The connection name or null for the default\n   */\n  connection?(): string | null\n\n  /**\n   * Get the queue the job should be sent to.\n   *\n   * @returns {string|null} The queue name or null for the default\n   */\n  queue?(): string | null\n\n  /**\n   * Get the delay (in seconds) before the job should be processed.\n   *\n   * @returns {number} The number of seconds to delay\n   */\n  delay?(): number\n}\n\n/**\n * DI token for IShouldQueue interface\n */\nexport namespace IShouldQueue {\n  export const $ = Symbol.for('IShouldQueue')\n}\n","import type { IQueueable } from './queueable.interface'\n\n/**\n * Interface for queue connections.\n * Queue connections are responsible for processing queueable jobs.\n */\nexport interface IQueueConnection {\n  /**\n   * Set the key prefix for queue items.\n   *\n   * @param prefix - The prefix to use\n   */\n  setKeyPrefix(prefix: string): void\n\n  /**\n   * Push a new job onto the queue.\n   *\n   * @param job - The job to queue\n   * @param data - Additional data for the job\n   * @param queue - The queue to push to\n   * @returns Promise resolving when the job is pushed\n   */\n  push(job: IQueueable, data: any, queue?: string): Promise<void>\n\n  /**\n   * Push a new job onto the queue after a delay.\n   *\n   * @param delay - The delay in seconds\n   * @param job - The job to queue\n   * @param data - Additional data for the job\n   * @param queue - The queue to push to\n   * @returns Promise resolving when the job is pushed\n   */\n  later(delay: number, job: IQueueable, data: any, queue?: string): Promise<void>\n\n  /**\n   * Push an array of jobs onto the queue.\n   *\n   * @param jobs - The jobs to queue\n   * @param data - Additional data for the jobs\n   * @param queue - The queue to push to\n   * @returns Promise resolving when all jobs are pushed\n   */\n  bulk(jobs: IQueueable[], data: any, queue?: string): Promise<void>\n\n  /**\n   * Process jobs in a queue.\n   *\n   * @param queue - The queue to process\n   * @param count - The number of jobs to process\n   * @returns The number of jobs processed\n   */\n  process(queue?: string, count?: number): Promise<number>\n\n  /**\n   * Get the number of jobs in a queue.\n   *\n   * @param queue - The queue name\n   * @returns The number of jobs\n   */\n  size(queue?: string): Promise<number>\n\n  /**\n   * Get the number of delayed jobs in a queue.\n   *\n   * @param queue - The queue name\n   * @returns The number of delayed jobs\n   */\n  delayedSize(queue?: string): Promise<number>\n\n  /**\n   * Clear all jobs in a queue.\n   *\n   * @param queue - The queue to clear\n   * @returns Promise resolving when the queue is cleared\n   */\n  clear(queue?: string): Promise<void>\n\n  /**\n   * Clear all queues.\n   *\n   * @returns Promise resolving when all queues are cleared\n   */\n  clearAll(): Promise<void>\n\n  /**\n   * Release a job back onto the queue.\n   *\n   * @param job - The job to release\n   * @param data - The job data\n   * @param delay - The delay in seconds\n   * @param queue - The queue to release to\n   * @returns Promise resolving when the job is released\n   */\n  release(job: IQueueable, data: any, delay?: number, queue?: string): Promise<void>\n\n  /**\n   * Move a job to the failed queue.\n   *\n   * @param job - The failed job\n   * @param data - The job data\n   * @param error - The error that caused the failure\n   * @returns Promise resolving when the job is moved\n   */\n  failed(job: IQueueable, data: any, error: Error): Promise<void>\n\n  /**\n   * Report progress for a job.\n   *\n   * @param job - The job to report progress for\n   * @param data - The job data\n   * @param progress - The progress percentage (0-100)\n   * @param progressData - Additional progress data\n   * @returns Promise resolving when the progress is reported\n   */\n  reportProgress?(job: IQueueable, data: any, progress: number, progressData?: any): Promise<void>\n\n  /**\n   * Listen for job events.\n   *\n   * @param event - The event name\n   * @param callback - The callback function\n   * @returns A function to remove the listener\n   */\n  on?(event: string, callback: (data: any) => void): () => void\n\n  /**\n   * Get all queues.\n   *\n   * @returns Promise resolving with an array of queue names\n   */\n  getQueues(): Promise<string[]>\n\n  /**\n   * Get all jobs in a queue.\n   *\n   * @param queue - The queue name\n   * @returns Promise resolving with an array of jobs\n   */\n  getJobs(\n    queue?: string,\n  ): Promise<Array<{ id: string; job: IQueueable; data: any; executeAt: number; attempts: number }>>\n\n  /**\n   * Get all failed jobs.\n   *\n   * @returns Promise resolving with an array of failed jobs\n   */\n  getFailedJobs(): Promise<\n    Array<{ id: string; job: IQueueable; data: any; error: Error; failedAt: number }>\n  >\n\n  /**\n   * Retry a failed job.\n   *\n   * @param id - The ID of the failed job\n   * @returns Promise resolving when the job is retried\n   */\n  retryFailed(id: string): Promise<void>\n\n  /**\n   * Retry all failed jobs.\n   *\n   * @returns Promise resolving with the number of jobs retried\n   */\n  retryAllFailed(): Promise<number>\n\n  /**\n   * Delete a failed job.\n   *\n   * @param id - The ID of the failed job\n   * @returns Promise resolving when the job is deleted\n   */\n  forgetFailed(id: string): Promise<void>\n\n  /**\n   * Delete all failed jobs.\n   *\n   * @returns Promise resolving when all failed jobs are deleted\n   */\n  flushFailed(): Promise<void>\n\n  /**\n   * Store a restart signal.\n   *\n   * @returns Promise resolving when the signal is stored\n   */\n  storeRestartSignal(): Promise<void>\n\n  /**\n   * Store a stop signal.\n   *\n   * @returns Promise resolving when the signal is stored\n   */\n  storeStopSignal(): Promise<void>\n\n  /**\n   * Check if a restart signal exists.\n   *\n   * @returns Promise resolving with true if a restart signal exists\n   */\n  shouldRestart(): Promise<boolean>\n\n  /**\n   * Check if a stop signal exists.\n   *\n   * @returns Promise resolving with true if a stop signal exists\n   */\n  shouldStop(): Promise<boolean>\n}\n\n/**\n * DI token for IQueueConnection interface\n */\nexport namespace IQueueConnection {\n  export const $ = Symbol.for('IQueueConnection')\n}\n","import type { IQueueConnection } from './queue-connection.interface'\nimport type { IQueueable } from './queueable.interface'\nimport { IWorker } from './worker.interface'\n\n/**\n * Interface for the queue manager.\n * The queue manager is responsible for managing queue connections and dispatching jobs.\n */\nexport interface IQueueManager {\n  /**\n   * Add a queue connection.\n   *\n   * @param name - The connection name\n   * @param connection - The queue connection\n   */\n  addConnection(name: string, connection: IQueueConnection): void\n\n  /**\n   * Get a queue connection by name.\n   *\n   * @param name - The connection name (or default if not provided)\n   * @returns The queue connection\n   */\n  connection(name?: string): IQueueConnection\n\n  /**\n   * Set the default connection name.\n   *\n   * @param name - The default connection name\n   */\n  setDefaultConnection(name: string): void\n\n  /**\n   * Create a worker for a connection and queue.\n   *\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns The worker\n   */\n  createWorker(connectionName?: string, queue?: string): IWorker\n\n  /**\n   * Push a new job onto the queue.\n   *\n   * @param job - The job to queue\n   * @param data - Additional data for the job\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns Promise resolving when the job is pushed\n   */\n  push(\n    job: IQueueable,\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Push a new job onto the queue after a delay.\n   *\n   * @param delay - The delay in seconds\n   * @param job - The job to queue\n   * @param data - Additional data for the job\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns Promise resolving when the job is pushed\n   */\n  later(\n    delay: number,\n    job: IQueueable,\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Push an array of jobs onto the queue.\n   *\n   * @param jobs - The jobs to queue\n   * @param data - Additional data for the jobs\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns Promise resolving when all jobs are pushed\n   */\n  bulk(\n    jobs: IQueueable[],\n    data: any,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Release a job back onto the queue.\n   *\n   * @param job - The job to release\n   * @param data - The job data\n   * @param delay - The delay in seconds\n   * @param connectionName - The connection name\n   * @param queue - The queue name\n   * @returns Promise resolving when the job is released\n   */\n  release(\n    job: IQueueable,\n    data: any,\n    delay?: number,\n    connectionName?: string | null,\n    queue?: string | null,\n  ): Promise<void>\n\n  /**\n   * Move a job to the failed queue.\n   *\n   * @param job - The failed job\n   * @param data - The job data\n   * @param error - The error that caused the failure\n   * @param connectionName - The connection name\n   * @returns Promise resolving when the job is moved\n   */\n  failed(job: IQueueable, data: any, error: Error, connectionName?: string | null): Promise<void>\n\n  /**\n   * Report progress for a job.\n   *\n   * @param job - The job to report progress for\n   * @param data - The job data\n   * @param progress - The progress percentage (0-100)\n   * @param progressData - Additional progress data\n   * @param connectionName - The connection name\n   * @returns Promise resolving when the progress is reported\n   */\n  reportProgress(\n    job: IQueueable,\n    data: any,\n    progress: number,\n    progressData?: any,\n    connectionName?: string | null,\n  ): Promise<void>\n\n  /**\n   * Listen for job events.\n   *\n   * @param event - The event name\n   * @param callback - The callback function\n   * @param connectionName - The connection name\n   * @returns A function to remove the listener\n   */\n  on(event: string, callback: (data: any) => void, connectionName?: string | null): () => void\n}\n\n/**\n * DI token for IQueueManager interface\n */\nexport namespace IQueueManager {\n  export const $ = Symbol.for('IQueueManager')\n}\n","import type { IQueueable } from './queueable.interface'\n\n/**\n * Interface for job registry\n * The job registry is responsible for registering and resolving job classes\n */\nexport interface IJobRegistry {\n  /**\n   * Register a job class.\n   *\n   * @param name - The name of the job class\n   * @param jobClass - The job class constructor\n   */\n  register(name: string, jobClass: new (...args: any[]) => IQueueable): void\n\n  /**\n   * Register multiple job classes.\n   *\n   * @param jobClasses - Map of job class names to constructors\n   */\n  registerMany(jobClasses: Map<string, new (...args: any[]) => IQueueable>): void\n\n  /**\n   * Check if a job class is registered.\n   *\n   * @param name - The name of the job class\n   * @returns True if the job class is registered\n   */\n  has(name: string): boolean\n\n  /**\n   * Get a job class by name.\n   *\n   * @param name - The name of the job class\n   * @returns The job class constructor\n   */\n  get(name: string): new (...args: any[]) => IQueueable\n\n  /**\n   * Create a new instance of a job class.\n   *\n   * @param name - The name of the job class\n   * @param args - Arguments to pass to the constructor\n   * @returns A new instance of the job class\n   */\n  make(name: string, ...args: any[]): IQueueable\n\n  /**\n   * Get all registered job classes.\n   *\n   * @returns Map of job class names to constructors\n   */\n  all(): Map<string, new (...args: any[]) => IQueueable>\n}\n\n/**\n * DI token for IJobRegistry interface\n */\nexport namespace IJobRegistry {\n  export const $ = Symbol.for('IJobRegistry')\n}\n","import { WorkerStatus } from '../../enums'\n\n/**\n * Interface for queue workers.\n * Workers are responsible for processing jobs from a queue.\n */\nexport interface IWorker {\n  /**\n   * Start the worker.\n   *\n   * @returns Promise resolving when the worker is started\n   */\n  start(): Promise<void>\n\n  /**\n   * Stop the worker.\n   *\n   * @returns Promise resolving when the worker is stopped\n   */\n  stop(): Promise<void>\n\n  /**\n   * Process the next job on the queue.\n   *\n   * @param queue - The queue to process\n   * @returns Promise resolving to true if a job was processed\n   */\n  processNext(queue?: string): Promise<boolean>\n\n  /**\n   * Get the current status of the worker.\n   *\n   * @returns The worker status\n   */\n  getStatus(): WorkerStatus\n\n  /**\n   * Set the maximum number of attempts for failed jobs.\n   *\n   * @param maxAttempts - The maximum number of attempts\n   */\n  setMaxAttempts(maxAttempts: number): void\n\n  /**\n   * Set the timeout for jobs.\n   *\n   * @param timeout - The timeout in seconds\n   */\n  setTimeout(timeout: number): void\n\n  /**\n   * Set the sleep time between polling the queue.\n   *\n   * @param sleep - The sleep time in seconds\n   */\n  setSleep(sleep: number): void\n\n  /**\n   * Set the concurrency level.\n   *\n   * @param concurrency - The number of jobs to process concurrently\n   */\n  setConcurrency(concurrency: number): void\n\n  /**\n   * Listen for worker events.\n   *\n   * @param event - The event name\n   * @param callback - The callback function\n   * @returns A function to remove the listener\n   */\n  on(event: string, callback: (data: any) => void): () => void\n}\n\n/**\n * DI token for IWorker interface\n */\nexport namespace IWorker {\n  export const $ = Symbol.for('IWorker')\n}\n","/**\n * Interface for rate limiter.\n */\nexport interface IRateLimiter {\n  /**\n   * Check if a key is rate limited.\n   *\n   * @param key - The key to check\n   * @param maxAttempts - The maximum number of attempts\n   * @param decaySeconds - The decay time in seconds\n   * @returns True if the key is rate limited\n   */\n  tooManyAttempts(key: string, maxAttempts: number, decaySeconds: number): Promise<boolean>\n\n  /**\n   * Increment the attempts for a key.\n   *\n   * @param key - The key to increment\n   * @param decaySeconds - The decay time in seconds\n   * @returns The current number of attempts\n   */\n  increment(key: string, decaySeconds: number): Promise<number>\n\n  /**\n   * Reset the attempts for a key.\n   *\n   * @param key - The key to reset\n   * @returns Promise resolving when the key is reset\n   */\n  reset(key: string): Promise<void>\n\n  /**\n   * Get the number of attempts for a key.\n   *\n   * @param key - The key to check\n   * @returns The number of attempts\n   */\n  attempts(key: string): Promise<number>\n\n  /**\n   * Get the number of remaining attempts for a key.\n   *\n   * @param key - The key to check\n   * @param maxAttempts - The maximum number of attempts\n   * @returns The number of remaining attempts\n   */\n  remaining(key: string, maxAttempts: number): Promise<number>\n\n  /**\n   * Get the time until the rate limit is reset.\n   *\n   * @param key - The key to check\n   * @returns The time in seconds until the rate limit is reset\n   */\n  availableIn(key: string): Promise<number>\n}\n\n/**\n * DI token for IRateLimiter interface\n */\nexport namespace IRateLimiter {\n  export const $ = Symbol.for('IRateLimiter')\n}\n","import type { ReactNode } from 'react'\nimport type { IApplication } from '../application'\n\n/**\n * Props for the AppProvider component\n * Provides the application instance to the React component tree\n */\nexport interface IAppProviderProps {\n  /**\n   * The Application instance to provide\n   */\n  app: IApplication\n\n  /**\n   * The children components\n   */\n  children: ReactNode\n\n  /**\n   * Whether to create a new container scope\n   * @default false\n   */\n  createScope?: boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IAppProviderProps {\n  /**\n   * Symbol for injecting the app provider props service\n   */\n  export const $ = Symbol.for('IAppProviderProps')\n}\n","import type { ReactNode } from 'react'\nimport type { IContainer } from '../container'\n\n/**\n * Props for the ContainerProvider component\n * Provides the container instance to the React component tree\n */\nexport interface IContainerProviderProps {\n  /**\n   * The Container instance to provide\n   */\n  container: IContainer\n\n  /**\n   * The children components\n   */\n  children: ReactNode\n\n  /**\n   * Whether to create a new container scope\n   * @default false\n   */\n  createScope?: boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IContainerProviderProps {\n  /**\n   * Symbol for injecting the container provider props service\n   */\n  export const $ = Symbol.for('IContainerProviderProps')\n}\n","/**\n * Result of the useCachedData hook\n * Provides access to data that is cached with automatic fetching\n */\nexport interface ICachedDataResult<T> {\n  /**\n   * The cached data\n   * Null if not loaded yet or if an error occurred\n   */\n  data: T | null\n\n  /**\n   * Whether the data is currently loading\n   */\n  loading: boolean\n\n  /**\n   * Any error that occurred during loading\n   */\n  error: Error | null\n\n  /**\n   * Function to refresh the data\n   * Fetches fresh data from the source and updates the cache\n   *\n   * @returns A promise that resolves when the refresh is complete\n   */\n  refresh: () => Promise<void>\n\n  /**\n   * Function to invalidate the cache\n   * Marks the current data as invalid, triggering a refresh on next access\n   *\n   * @returns A promise that resolves when the invalidation is complete\n   */\n  invalidate: () => Promise<void>\n\n  /**\n   * The timestamp when the data was last updated\n   */\n  lastUpdated: Date | null\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ICachedDataResult {\n  /**\n   * Symbol for injecting the cached data result service\n   */\n  export const $ = Symbol.for('ICachedDataResult')\n}\n","/**\n * Result of the useCacheValue hook\n * Provides access to and control over a cached value\n */\nexport interface ICacheValueResult<T> {\n  /**\n   * The cached value\n   * Null if the value doesn't exist, undefined if it's still loading\n   */\n  value: T | null | undefined\n\n  /**\n   * Function to set the value in the cache\n   *\n   * @param newValue - The new value to cache\n   * @param ttl - Optional time-to-live in seconds\n   * @returns A promise resolving to whether the operation succeeded\n   */\n  setValue: (newValue: T, ttl?: number) => Promise<boolean>\n\n  /**\n   * Function to remove the value from the cache\n   *\n   * @returns A promise resolving to whether the operation succeeded\n   */\n  removeValue: () => Promise<boolean>\n\n  /**\n   * Whether the value is currently loading\n   */\n  loading: boolean\n\n  /**\n   * Function to refresh the value from the cache\n   *\n   * @returns A promise that resolves when the refresh is complete\n   */\n  refresh: () => Promise<void>\n\n  /**\n   * Any error that occurred during loading or operations\n   */\n  error: Error | null\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace ICacheValueResult {\n  /**\n   * Symbol for injecting the cache value result service\n   */\n  export const $ = Symbol.for('ICacheValueResult')\n}\n","import type { ICommand } from './command.interface'\n\n/**\n * Interface for the console application\n *\n * Manages the console commands and their execution.\n */\nexport interface IApplication {\n  /**\n   * Registers a command with the application\n   *\n   * @param {ICommand} command - The command to register\n   * @returns {IApplication} - The application instance for chaining\n   */\n  register(command: ICommand): IApplication\n\n  /**\n   * Registers multiple commands with the application\n   *\n   * @param {ICommand[]} commands - The commands to register\n   * @returns {IApplication} - The application instance for chaining\n   */\n  registerCommands(commands: ICommand[]): IApplication\n\n  /**\n   * Discovers and registers commands from a directory\n   *\n   * @param {string} directory - The directory to scan for commands\n   * @param {string} pattern - The glob pattern to match command files\n   * @returns {Promise<IApplication>} - The application instance for chaining\n   */\n  discoverCommands(directory: string, pattern?: string): Promise<IApplication>\n\n  /**\n   * Runs the application with the given arguments\n   *\n   * @param {string[]} argv - The command line arguments\n   * @returns {Promise<void>}\n   */\n  run(argv?: string[]): Promise<void>\n}\n\n/**\n * Namespace for IApplication interface\n *\n * Contains token for dependency injection\n */\nexport namespace IApplication {\n  /**\n   * Token for the IApplication interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IApplication')\n}\n","import { IAsk } from './ask.interface'\nimport type { IInput } from './input.interface'\nimport type { IOutput } from './output.interface'\nimport { IProgressBarFormat } from './progress-bar-format.interface'\nimport { IProgressBar } from './progress-bar.interface'\nimport { ITableOutput } from './table-output.interface'\nimport { ITableStyle } from './table-style.interface'\n\n/**\n * Interface for console command classes.\n *\n * Defines the structure and lifecycle of a command,\n * including argument/option handling and execution hooks.\n */\nexport interface ICommand {\n  /**\n   * Gets the name of the command.\n   *\n   * @returns The command name.\n   */\n  getName(): string\n\n  /**\n   * Gets the description of the command.\n   *\n   * @returns The command description.\n   */\n  getDescription(): string\n\n  /**\n   * Sets the input instance for the command.\n   *\n   * @param input - The input instance to set.\n   */\n  setInput(input: IInput): void\n\n  /**\n   * Gets the current input instance.\n   *\n   * @returns The input instance.\n   */\n  getInput(): IInput\n\n  /**\n   * Sets the output instance for the command.\n   *\n   * @param output - The output instance to set.\n   */\n  setOutput(output: IOutput): void\n\n  /**\n   * Gets the current output instance.\n   *\n   * @returns The output instance.\n   */\n  getOutput(): IOutput\n\n  /**\n   * Sets multiple arguments by index or name.\n   *\n   * @param args - Array of positional arguments.\n   */\n  setArguments(args: string[]): void\n\n  /**\n   * Sets a single named argument.\n   *\n   * @param key - Argument key.\n   * @param value - Argument value.\n   */\n  setArgument(key: string, value: any): void\n\n  /**\n   * Gets all arguments.\n   *\n   * @returns A key-value map of arguments.\n   */\n  getArguments(): Record<string, any>\n\n  /**\n   * Gets a single argument by name.\n   *\n   * @param key - Argument name.\n   * @param defaultValue - default value .\n   * @returns The value or undefined.\n   */\n  getArgument<T = any>(key: string, defaultValue?: string): T | undefined\n\n  /**\n   * Sets multiple options by key.\n   *\n   * @param options - Key-value map of options.\n   */\n  setOptions(options: Record<string, any>): void\n\n  /**\n   * Sets a single option.\n   *\n   * @param key - Option key.\n   * @param value - Option value.\n   */\n  setOption(key: string, value: any): void\n\n  /**\n   * Gets all options.\n   *\n   * @returns A key-value map of options.\n   */\n  getOptions(): Record<string, any>\n\n  /**\n   * Gets a single option by key.\n   *\n   * @param key - Option name.\n   * @param defaultValue - default value .\n   * @returns The value or undefined.\n   */\n  getOption<T = any>(key: string, defaultValue?: string): T | undefined\n\n  /**\n   * Allows a command to define its expected arguments and options.\n   * Called before execution.\n   */\n  configure(): void\n\n  /**\n   * Main execution logic of the command.\n   * Must return a status code (or void).\n   *\n   * @returns Promise resolving to exit code or void.\n   */\n  execute(): Promise<number | void>\n\n  /**\n   * Hook called before command execution.\n   * Return false to cancel execution.\n   *\n   * @returns Whether to continue execution.\n   */\n  beforeExecute(): Promise<boolean>\n\n  /**\n   * Hook called after command execution.\n   *\n   * @param exitCode - The result from execute().\n   */\n  afterExecute(exitCode: number | void): Promise<void>\n\n  /**\n   * Ask utility class\n   *\n   * @returns Ask utility class\n   */\n  ask(): IAsk\n\n  /**\n   * Creates a new ProgressBar instance\n   *\n   * @param {number} total - The total value\n   * @param {IProgressBarFormat} format - The format options\n   */\n  progress(total: number, format?: IProgressBarFormat): IProgressBar\n\n  /**\n   * Creates a new TableOutput instance\n   *\n   * @param {string[]} headers - The table headers\n   * @param {ITableStyle} style - The table style\n   */\n  table(headers: string[], style?: ITableStyle): ITableOutput\n}\n\n/**\n * Namespace for ICommand interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommand {\n  /**\n   * Token for the ICommand interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommand')\n}\n","import type { ICommand } from './command.interface'\n\n/**\n * Interface for the command registry\n *\n * Stores and manages all registered commands.\n */\nexport interface ICommandRegistry {\n  /**\n   * Adds a command to the registry\n   *\n   * @param {ICommand} command - The command to add\n   * @throws {Error} If a command with the same name already exists\n   */\n  add(command: ICommand): void\n\n  /**\n   * Gets a command by name\n   *\n   * @param {string} name - The name of the command\n   * @returns {ICommand | undefined} The command or undefined if not found\n   */\n  get(name: string): ICommand | undefined\n\n  /**\n   * Gets all registered commands\n   *\n   * @returns {ICommand[]} Array of all registered commands\n   */\n  getAll(): ICommand[]\n\n  /**\n   * Checks if a command exists\n   *\n   * @param {string} name - The name of the command\n   * @returns {boolean} True if the command exists, false otherwise\n   */\n  has(name: string): boolean\n\n  /**\n   * Removes a command from the registry\n   *\n   * @param {string} name - The name of the command\n   * @returns {boolean} True if the command was removed, false otherwise\n   */\n  remove(name: string): boolean\n\n  /**\n   * Clears all commands from the registry\n   */\n  clear(): void\n}\n\n/**\n * Namespace for ICommandRegistry interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandRegistry {\n  /**\n   * Token for the ICommandRegistry interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandRegistry')\n}\n","import type { ICommand } from './command.interface'\n\n/**\n * Interface for command collector\n *\n * Discovers and collects commands from the file system.\n */\nexport interface ICommandCollector {\n  /**\n   * Discovers commands in the specified directory\n   *\n   * @param {string} directory - The directory to scan for commands\n   * @param {string} pattern - The glob pattern to match command files\n   * @returns {Promise<ICommand[]>} The discovered commands\n   */\n  discoverCommands(directory: string, pattern?: string): Promise<ICommand[]>\n\n  /**\n   * Gets all commands that have been registered with the container\n   *\n   * @returns {ICommand[]} The registered commands\n   */\n  getRegisteredCommands(): ICommand[]\n\n  /**\n   * Gets command metadata for a command class\n   *\n   * @param {Function} commandClass - The command class\n   * @returns {any} The command metadata\n   */\n  getCommandMetadata(commandClass: Function): any\n}\n\n/**\n * Namespace for ICommandCollector interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandCollector {\n  /**\n   * Token for the ICommandCollector interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandCollector')\n}\n","import type { IScheduleExpression } from './schedule-expression.interface'\nimport type { IScheduledTask } from './scheduled-task.interface'\n\n/**\n * Interface for the command scheduler\n *\n * Schedules commands to run at specific intervals.\n */\nexport interface ICommandScheduler {\n  /**\n   * Schedules a command to run at a specific interval\n   *\n   * @param {string} commandName - The name of the command\n   * @param {IScheduleExpression} expression - The schedule expression\n   * @param {string[]} args - The arguments to pass to the command\n   * @param {Record<string, any>} options - The options to pass to the command\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  schedule(\n    commandName: string,\n    expression: IScheduleExpression,\n    args?: string[],\n    options?: Record<string, any>,\n  ): ICommandScheduler\n\n  /**\n   * Starts the scheduler\n   *\n   * @param {number} interval - The interval in milliseconds to check for tasks to run\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  start(interval?: number): ICommandScheduler\n\n  /**\n   * Stops the scheduler\n   *\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  stop(): ICommandScheduler\n\n  /**\n   * Gets all scheduled tasks\n   *\n   * @returns {IScheduledTask[]} The scheduled tasks\n   */\n  getTasks(): IScheduledTask[]\n\n  /**\n   * Clears all scheduled tasks\n   *\n   * @returns {ICommandScheduler} The scheduler instance for chaining\n   */\n  clearTasks(): ICommandScheduler\n}\n\n/**\n * Namespace for ICommandScheduler interface\n *\n * Contains token for dependency injection\n */\nexport namespace ICommandScheduler {\n  /**\n   * Token for the ICommandScheduler interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ICommandScheduler')\n}\n","/**\n * Interface for console input\n *\n * Provides methods for accessing command line arguments and options.\n */\nexport interface IInput {\n  /**\n   * Gets the command name from the input\n   *\n   * @returns {string | undefined} The command name or undefined if not provided\n   */\n  getCommandName(): string | undefined\n\n  /**\n   * Gets an argument value by name\n   *\n   * @param {string} name - The name of the argument\n   * @returns {string | undefined} The argument value or undefined if not provided\n   */\n  getArgument(name: string): string | undefined\n\n  /**\n   * Gets all arguments\n   *\n   * @returns {Record<string, string>} Map of argument names to values\n   */\n  getArguments(): Record<string, string>\n\n  /**\n   * Gets an option value by name\n   *\n   * @param {string} name - The name of the option\n   * @returns {string | boolean | undefined} The option value or undefined if not provided\n   */\n  getOption(name: string): string | boolean | undefined\n\n  /**\n   * Gets all options\n   *\n   * @returns {Record<string, string | boolean>} Map of option names to values\n   */\n  getOptions(): Record<string, string | boolean>\n\n  /**\n   * Checks if an option is set\n   *\n   * @param {string} name - The name of the option\n   * @returns {boolean} True if the option is set, false otherwise\n   */\n  hasOption(name: string): boolean\n}\n\n/**\n * Namespace for IInput interface\n *\n * Contains token for dependency injection\n */\nexport namespace IInput {\n  /**\n   * Token for the IInput interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IInput')\n}\n","/**\n * Interface for console output\n *\n * Provides methods for writing to the console.\n */\nexport interface IOutput {\n  /**\n   * Writes a message to the output\n   *\n   * @param {string} message - The message to write\n   */\n  write(message: string): void\n\n  /**\n   * Writes a message to the output followed by a newline\n   *\n   * @param {string} message - The message to write\n   */\n  writeln(message: string): void\n\n  /**\n   * Writes an error message to the output\n   *\n   * @param {string} message - The error message to write\n   */\n  error(message: string): void\n\n  /**\n   * Writes a success message to the output\n   *\n   * @param {string} message - The success message to write\n   */\n  success(message: string): void\n\n  /**\n   * Writes an info message to the output\n   *\n   * @param {string} message - The info message to write\n   */\n  info(message: string): void\n\n  /**\n   * Writes a warning message to the output\n   *\n   * @param {string} message - The warning message to write\n   */\n  warning(message: string): void\n\n  /**\n   * Writes a comment message to the output\n   *\n   * @param {string} message - The comment message to write\n   */\n  comment(message: string): void\n}\n\n/**\n * Namespace for IOutput interface\n *\n * Contains token for dependency injection\n */\nexport namespace IOutput {\n  /**\n   * Token for the IOutput interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IOutput')\n}\n","/**\n * Interface for the stub generator\n *\n * Handles the generation of files from stub templates.\n */\nexport interface IStubGenerator {\n  /**\n   * Generates a file from a stub template\n   *\n   * @param {string} stubName - The name of the stub template\n   * @param {string} outputPath - The path where the generated file will be saved\n   * @param {Record<string, string>} replacements - Map of placeholders to their replacements\n   * @returns {boolean} True if the file was generated successfully, false otherwise\n   */\n  generate(stubName: string, outputPath: string, replacements: Record<string, string>): boolean\n\n  /**\n   * Gets the list of available stub templates\n   *\n   * @returns {string[]} Array of stub template names\n   */\n  getAvailableStubs(): string[]\n}\n\n/**\n * Namespace for IStubGenerator interface\n *\n * Contains token for dependency injection\n */\nexport namespace IStubGenerator {\n  /**\n   * Token for the IStubGenerator interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IStubGenerator')\n}\n","import type { IQuestion } from './question.interface'\n\n/**\n * Interface for ask utility\n *\n * Provides methods for asking questions in the console.\n */\nexport interface IAsk {\n  /**\n   * Asks a single question\n   *\n   * @param {IQuestion} question - The question to ask\n   * @returns {Promise<any>} The answer\n   */\n  question(question: IQuestion): Promise<any>\n\n  /**\n   * Asks multiple questions\n   *\n   * @param {IQuestion[]} questions - The questions to ask\n   * @returns {Promise<Record<string, any>>} The answers\n   */\n  questions(questions: IQuestion[]): Promise<Record<string, any>>\n\n  /**\n   * Asks for input\n   *\n   * @param {string} message - The message to display\n   * @param {string} defaultValue - The default value\n   * @returns {Promise<string>} The input\n   */\n  input(message: string, defaultValue?: string): Promise<string>\n\n  /**\n   * Asks for confirmation\n   *\n   * @param {string} message - The message to display\n   * @param {boolean} defaultValue - The default value\n   * @returns {Promise<boolean>} The confirmation\n   */\n  confirm(message: string, defaultValue?: boolean): Promise<boolean>\n\n  /**\n   * Asks for a selection from a list\n   *\n   * @param {string} message - The message to display\n   * @param {string[] | { name: string; value: any }[]} choices - The choices\n   * @param {any} defaultValue - The default value\n   * @returns {Promise<any>} The selection\n   */\n  select(\n    message: string,\n    choices: string[] | { name: string; value: any }[],\n    defaultValue?: any,\n  ): Promise<any>\n\n  /**\n   * Asks for multiple selections from a list\n   *\n   * @param {string} message - The message to display\n   * @param {string[] | { name: string; value: any }[]} choices - The choices\n   * @param {any[]} defaultValue - The default values\n   * @returns {Promise<any[]>} The selections\n   */\n  multiSelect(\n    message: string,\n    choices: string[] | { name: string; value: any }[],\n    defaultValue?: any[],\n  ): Promise<any[]>\n\n  /**\n   * Asks for a password\n   *\n   * @param {string} message - The message to display\n   * @returns {Promise<string>} The password\n   */\n  password(message: string): Promise<string>\n}\n\n/**\n * Namespace for IAsk interface\n *\n * Contains token for dependency injection\n */\nexport namespace IAsk {\n  /**\n   * Token for the IAsk interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IAsk')\n}\n","/**\n * Interface for table output\n *\n * Provides methods for displaying tables in the console.\n */\nexport interface ITableOutput {\n  /**\n   * Adds a row to the table\n   *\n   * @param {any[]} row - The row data\n   * @returns {ITableOutput} The table instance for chaining\n   */\n  addRow(row: any[]): ITableOutput\n\n  /**\n   * Adds multiple rows to the table\n   *\n   * @param {any[][]} rows - The rows data\n   * @returns {ITableOutput} The table instance for chaining\n   */\n  addRows(rows: any[][]): ITableOutput\n\n  /**\n   * Renders the table to a string\n   *\n   * @returns {string} The rendered table\n   */\n  toString(): string\n\n  /**\n   * Renders the table to the console\n   */\n  render(): void\n}\n\n/**\n * Namespace for ITableOutput interface\n *\n * Contains token for dependency injection\n */\nexport namespace ITableOutput {\n  /**\n   * Token for the ITableOutput interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('ITableOutput')\n}\n","import type { MultiBar } from 'cli-progress'\n\n/**\n * Interface for progress bar\n *\n * Provides methods for displaying progress bars in the console.\n */\nexport interface IProgressBar {\n  /**\n   * Updates the progress bar\n   *\n   * @param {number} value - The current value\n   * @param {Record<string, any>} payload - Additional payload data\n   */\n  update(value: number, payload?: Record<string, any>): void\n\n  /**\n   * Increments the progress bar\n   *\n   * @param {number} value - The value to increment by\n   * @param {Record<string, any>} payload - Additional payload data\n   */\n  increment(value?: number, payload?: Record<string, any>): void\n\n  /**\n   * Stops the progress bar\n   */\n  stop(): void\n}\n\n/**\n * Namespace for IProgressBar interface\n *\n * Contains token for dependency injection\n */\nexport namespace IProgressBar {\n  /**\n   * Token for the IProgressBar interface\n   * Used for dependency injection\n   */\n  export const $ = Symbol('IProgressBar')\n}\n","import type { IRedisConnection } from './connection.interface'\n\n/**\n * Redis factory interface\n * Responsible for creating and managing Redis connections\n */\nexport interface IRedisFactory {\n  /**\n   * Get a Redis connection by name\n   * @param name - The connection name (optional, uses default if not provided)\n   * @returns A Redis connection instance\n   *\n   * @example\n   * ```typescript\n   * // Get the default connection\n   * const redis = factory.connection();\n   *\n   * // Get a specific named connection\n   * const cache = factory.connection('cache');\n   * ```\n   */\n  connection(name?: string): IRedisConnection\n\n  /**\n   * Create a new Redis connection\n   * @param config - The connection configuration\n   * @returns A Redis connection instance\n   */\n  make(config: Record<string, any>): IRedisConnection\n\n  /**\n   * Get the default connection name\n   * @returns The default connection name\n   */\n  getDefaultConnection(): string\n\n  /**\n   * Set the default connection name\n   * @param name - The default connection name\n   */\n  setDefaultConnection(name: string): void\n\n  /**\n   * Get all registered connections\n   * @returns A record of connection names to connection instances\n   */\n  getConnections(): Record<string, IRedisConnection>\n\n  /**\n   * Check if a connection exists\n   * @param name - The connection name\n   * @returns True if the connection exists\n   */\n  hasConnection(name: string): boolean\n\n  /**\n   * Add a connection to the factory\n   * @param name - The connection name\n   * @param connection - The connection instance\n   */\n  addConnection(name: string, connection: IRedisConnection): void\n\n  /**\n   * Remove a connection from the factory\n   * @param name - The connection name\n   */\n  removeConnection(name: string): void\n}\n\n/**\n * DI token for IRedisFactory interface\n */\nexport namespace IRedisFactory {\n  export const $ = Symbol.for('IRedisFactory')\n}\n","import type { IRedisConnection } from './connection.interface'\n\n/**\n * Redis connector interface\n * Defines the standard methods that all Redis connectors must implement\n */\nexport interface IRedisConnector {\n  /**\n   * Create a Redis client connection\n   * @param config - The connection configuration\n   * @returns A Redis connection instance\n   */\n  createClient(config: Record<string, any>): IRedisConnection\n\n  /**\n   * Create a Redis cluster connection\n   * @param config - The connection configuration\n   * @returns A Redis connection instance\n   */\n  createCluster(config: Record<string, any>): IRedisConnection\n}\n\n/**\n * DI token for IRedisConnector interface\n */\nexport namespace IRedisConnector {\n  export const $ = Symbol.for('IRedisConnector')\n}\n","/**\n * Redis connection interface\n * Defines methods for interacting with Redis, including pub/sub functionality\n */\nexport interface IRedisConnection {\n  /**\n   * Subscribe to one or more channels for messages\n   * @param channels - The channel(s) to subscribe to\n   * @param callback - The callback function to execute when a message is received\n   * @returns Promise that resolves when the subscription is active\n   *\n   * @example\n   * ```typescript\n   * await redis.subscribe(['notifications', 'events'], (message, channel) => {\n   *   console.log(`Received message on ${channel}: ${message}`);\n   * });\n   * ```\n   */\n  subscribe(\n    channels: string | string[],\n    callback: (message: string, channel: string) => void,\n  ): Promise<void>\n\n  /**\n   * Subscribe to one or more channels with wildcards\n   * @param patterns - The pattern(s) to subscribe to\n   * @param callback - The callback function to execute when a message is received\n   * @returns Promise that resolves when the subscription is active\n   *\n   * @example\n   * ```typescript\n   * await redis.psubscribe(['user:*:notifications', 'system:*'], (message, channel, pattern) => {\n   *   console.log(`Received message on ${channel} matching ${pattern}: ${message}`);\n   * });\n   * ```\n   */\n  psubscribe(\n    patterns: string | string[],\n    callback: (message: string, channel: string, pattern: string) => void,\n  ): Promise<void>\n\n  /**\n   * Run a command against the Redis database\n   * @param method - The Redis command to execute\n   * @param parameters - The parameters for the command\n   * @returns The result of the command\n   *\n   * @example\n   * ```typescript\n   * // Execute a SET command\n   * const result = await redis.command('set', ['user:1:name', 'John Doe']);\n   *\n   * // Execute a HGETALL command\n   * const userData = await redis.command('hgetall', ['user:1']);\n   * ```\n   */\n  command(method: string, parameters?: any[]): Promise<any>\n\n  /**\n   * Get the Redis client instance\n   */\n  getClient(): any\n\n  /**\n   * Get the key prefix\n   */\n  getPrefix(): string\n\n  /**\n   * Set the key prefix\n   * @param prefix - The key prefix\n   */\n  setPrefix(prefix: string): void\n\n  /**\n   * Get a value from Redis\n   * @param key - The key\n   */\n  get(key: string): Promise<any>\n\n  /**\n   * Set a value in Redis\n   * @param key - The key\n   * @param value - The value\n   * @param ttl - The time to live in seconds\n   */\n  set(key: string, value: any, ttl?: number): Promise<any>\n\n  /**\n   * Set a value in Redis if it doesn't exist\n   * @param key - The key\n   * @param value - The value\n   * @param ttl - The time to live in seconds\n   */\n  setnx(key: string, value: any, ttl?: number): Promise<any>\n\n  /**\n   * Set a value in Redis with an expiration\n   * @param key - The key\n   * @param ttl - The time to live in seconds\n   * @param value - The value\n   */\n  setex(key: string, ttl: number, value: any): Promise<any>\n\n  /**\n   * Get multiple values from Redis\n   * @param keys - The keys\n   */\n  mget(...keys: string[]): Promise<any[]>\n\n  /**\n   * Set multiple values in Redis\n   * @param values - The key-value pairs\n   */\n  mset(values: Record<string, any>): Promise<any>\n\n  /**\n   * Delete a key from Redis\n   * @param key - The key\n   */\n  del(key: string): Promise<number>\n\n  /**\n   * Delete multiple keys from Redis\n   * @param keys - The keys\n   */\n  unlink(...keys: string[]): Promise<number>\n\n  /**\n   * Check if a key exists in Redis\n   * @param key - The key\n   */\n  exists(key: string): Promise<number>\n\n  /**\n   * Increment a value in Redis\n   * @param key - The key\n   */\n  incr(key: string): Promise<number>\n\n  /**\n   * Increment a value in Redis by a specific amount\n   * @param key - The key\n   * @param value - The value to increment by\n   */\n  incrby(key: string, value: number): Promise<number>\n\n  /**\n   * Decrement a value in Redis\n   * @param key - The key\n   */\n  decr(key: string): Promise<number>\n\n  /**\n   * Decrement a value in Redis by a specific amount\n   * @param key - The key\n   * @param value - The value to decrement by\n   */\n  decrby(key: string, value: number): Promise<number>\n\n  /**\n   * Set a key's time to live in seconds\n   * @param key - The key\n   * @param ttl - The time to live in seconds\n   */\n  expire(key: string, ttl: number): Promise<number>\n\n  /**\n   * Get the time to live for a key in seconds\n   * @param key - The key\n   */\n  ttl(key: string): Promise<number>\n\n  /**\n   * Execute a Lua script\n   * @param script - The Lua script\n   * @param keys - The keys\n   * @param args - The arguments\n   */\n  eval(script: string, keys: string[], args: any[]): Promise<any>\n\n  /**\n   * Execute a stored Lua script\n   * @param sha - The script SHA\n   * @param keys - The keys\n   * @param args - The arguments\n   */\n  evalsha(sha: string, keys: string[], args: any[]): Promise<any>\n\n  /**\n   * Add a member to a set\n   * @param key - The key\n   * @param members - The members\n   */\n  sadd(key: string, ...members: any[]): Promise<number>\n\n  /**\n   * Remove a member from a set\n   * @param key - The key\n   * @param members - The members\n   */\n  srem(key: string, ...members: any[]): Promise<number>\n\n  /**\n   * Get all members in a set\n   * @param key - The key\n   */\n  smembers(key: string): Promise<string[]>\n\n  /**\n   * Check if a value is a member of a set\n   * @param key - The key\n   * @param member - The member\n   */\n  sismember(key: string, member: any): Promise<number>\n\n  /**\n   * Add a member to a sorted set\n   * @param key - The key\n   * @param score - The score\n   * @param member - The member\n   */\n  zadd(key: string, score: number, member: any): Promise<number>\n\n  /**\n   * Remove a member from a sorted set\n   * @param key - The key\n   * @param member - The member\n   */\n  zrem(key: string, member: any): Promise<number>\n\n  /**\n   * Get a range of members in a sorted set\n   * @param key - The key\n   * @param start - The start index\n   * @param stop - The stop index\n   */\n  zrange(key: string, start: number, stop: number): Promise<string[]>\n\n  /**\n   * Add a value to a list\n   * @param key - The key\n   * @param values - The values\n   */\n  lpush(key: string, ...values: any[]): Promise<number>\n\n  /**\n   * Remove and get the first element in a list\n   * @param key - The key\n   */\n  lpop(key: string): Promise<string | null>\n\n  /**\n   * Add a value to a list\n   * @param key - The key\n   * @param values - The values\n   */\n  rpush(key: string, ...values: any[]): Promise<number>\n\n  /**\n   * Remove and get the last element in a list\n   * @param key - The key\n   */\n  rpop(key: string): Promise<string | null>\n\n  /**\n   * Get a range of elements from a list\n   * @param key - The key\n   * @param start - The start index\n   * @param stop - The stop index\n   */\n  lrange(key: string, start: number, stop: number): Promise<string[]>\n\n  /**\n   * Set the value of a hash field\n   * @param key - The key\n   * @param field - The field\n   * @param value - The value\n   */\n  hset(key: string, field: string, value: any): Promise<number>\n\n  /**\n   * Get the value of a hash field\n   * @param key - The key\n   * @param field - The field\n   */\n  hget(key: string, field: string): Promise<string | null>\n\n  /**\n   * Delete a hash field\n   * @param key - The key\n   * @param fields - The fields\n   */\n  hdel(key: string, ...fields: string[]): Promise<number>\n\n  /**\n   * Get all fields and values in a hash\n   * @param key - The key\n   */\n  hgetall(key: string): Promise<Record<string, string>>\n\n  /**\n   * Set multiple hash fields to multiple values\n   * @param key - The key\n   * @param values - The field-value pairs\n   */\n  hmset(key: string, values: Record<string, any>): Promise<any>\n\n  /**\n   * Get the values of all the given hash fields\n   * @param key - The key\n   * @param fields - The fields\n   */\n  hmget(key: string, ...fields: string[]): Promise<(string | null)[]>\n\n  /**\n   * Execute a pipeline of commands\n   * @param callback - The callback function\n   */\n  pipeline(callback: (pipeline: any) => void): Promise<any[]>\n\n  /**\n   * Execute a transaction\n   * @param callback - The callback function\n   */\n  transaction(callback: (transaction: any) => void): Promise<any[]>\n\n  /**\n   * Publish a message to a channel\n   * @param channel - The channel\n   * @param message - The message\n   */\n  publish(channel: string, message: string): Promise<number>\n\n  /**\n   * Close the Redis connection\n   */\n  disconnect(): Promise<void>\n}\n\n/**\n * DI token for IRedisConnection interface\n */\nexport namespace IRedisConnection {\n  export const $ = Symbol.for('IRedisConnection')\n}\n","export namespace IRedis {\n  export const $ = Symbol.for('IRedis')\n}\n","/**\n * Interface for route controllers\n * Defines the contract that all controller classes must implement\n */\nexport interface IController {\n  /**\n   * The constructor of the controller\n   * Controllers should be instantiable with dependency injection\n   */\n  new (...args: any[]): any\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IController {\n  /**\n   * Symbol for injecting the controller service\n   */\n  export const $ = Symbol.for('IController')\n}\n","/**\n * Options for the Controller decorator\n * Configures controller-specific behavior\n */\nexport interface IControllerOptions {\n  /**\n   * Controller-specific middleware\n   * These are executed for all routes in the controller\n   */\n  middleware?: any[]\n\n  /**\n   * Controller-specific guards\n   * These are executed for all routes in the controller\n   */\n  guards?: any[]\n\n  /**\n   * The API version this controller belongs to\n   * Used when versioning is enabled in router configuration\n   */\n  version?: string\n\n  /**\n   * Additional metadata for the controller\n   * Can be used for documentation, validation, or custom extensions\n   */\n  metadata?: Record<string, any>\n\n  /**\n   * Controller description for documentation\n   */\n  description?: string\n\n  /**\n   * Whether the controller is deprecated\n   * @default false\n   */\n  deprecated?: boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IControllerOptions {\n  /**\n   * Symbol for injecting the controller options service\n   */\n  export const $ = Symbol.for('IControllerOptions')\n}\n","import type { NextApiRequest, NextApiResponse } from 'next'\n\n/**\n * Interface for route handlers\n * Route handlers process requests and generate responses\n */\nexport interface IRouteHandler {\n  /**\n   * The route handler function\n   *\n   * @param req - The Next.js API request\n   * @param res - The Next.js API response\n   * @param args - Additional arguments provided by parameter decorators\n   * @returns The response data or a promise resolving to the response data\n   */\n  (req: NextApiRequest, res: NextApiResponse, ...args: any[]): Promise<any> | any\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IRouteHandler {\n  /**\n   * Symbol for injecting the route handler service\n   */\n  export const $ = Symbol.for('IRouteHandler')\n}\n","/**\n * Options for the Route decorator\n * Configures route-specific behavior\n */\nexport interface IRouteOptions {\n  /**\n   * Route-specific middleware\n   * These are executed after controller middleware but before the route handler\n   */\n  middleware?: any[]\n\n  /**\n   * Route-specific guards\n   * These are executed after controller guards but before the route handler\n   */\n  guards?: any[]\n\n  /**\n   * Additional metadata for the route\n   * Can be used for documentation, validation, or custom extensions\n   */\n  metadata?: Record<string, any>\n\n  /**\n   * Whether the route is deprecated\n   * @default false\n   */\n  deprecated?: boolean\n\n  /**\n   * Route description for documentation\n   */\n  description?: string\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IRouteOptions {\n  /**\n   * Symbol for injecting the route options service\n   */\n  export const $ = Symbol.for('IRouteOptions')\n}\n","import type { NextApiRequest, NextApiResponse } from 'next'\n\n/**\n * Interface for route middleware\n * Middleware intercepts requests before they reach the route handler\n * and can modify the request/response or terminate the request early\n */\nexport interface IMiddleware {\n  /**\n   * Middleware handler function\n   *\n   * @param req - The Next.js API request\n   * @param res - The Next.js API response\n   * @param next - The next function to call to continue the middleware chain\n   * @returns A promise that resolves when the middleware has completed\n   */\n  (req: NextApiRequest, res: NextApiResponse, next: () => Promise<void>): Promise<void>\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IMiddleware {\n  /**\n   * Symbol for injecting the middleware service\n   */\n  export const $ = Symbol.for('IMiddleware')\n}\n","import type { NextApiRequest, NextApiResponse } from 'next'\n\n/**\n * Interface for route guards\n * Guards determine whether a route handler should be executed\n * They are typically used for authentication and authorization\n */\nexport interface IGuard {\n  /**\n   * Check if the request is allowed to proceed to the route handler\n   *\n   * @param req - The Next.js API request\n   * @param res - The Next.js API response\n   * @returns A boolean or promise resolving to a boolean indicating whether the request should proceed\n   */\n  canActivate(req: NextApiRequest, res: NextApiResponse): Promise<boolean> | boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IGuard {\n  /**\n   * Symbol for injecting the guard service\n   */\n  export const $ = Symbol.for('IGuard')\n}\n","import type { ParamType } from '../../enums'\n\n/**\n * Interface for parameter metadata\n * Describes how controller method parameters should be resolved\n */\nexport interface IParamMetadata {\n  /**\n   * The parameter index in the method signature\n   */\n  index: number\n\n  /**\n   * The parameter type (e.g., PARAM, QUERY, BODY)\n   */\n  type: ParamType\n\n  /**\n   * The parameter name to extract from the request\n   * If null, the entire object of the specified type is passed\n   */\n  name: string | null\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IParamMetadata {\n  /**\n   * Symbol for injecting the param metadata service\n   */\n  export const $ = Symbol.for('IParamMetadata')\n}\n","/**\n * Interface for router configuration\n * Defines global settings for the router\n */\nexport interface IRouterConfig {\n  /**\n   * The base path for all routes\n   * @default \"/api\"\n   */\n  basePath?: string\n\n  /**\n   * Whether to automatically register controllers\n   * When true, controllers are discovered and registered at startup\n   * @default true\n   */\n  autoRegister?: boolean\n\n  /**\n   * Default middleware for all routes\n   * These are executed before controller and route middleware\n   */\n  globalMiddleware?: any[]\n\n  /**\n   * Default guards for all routes\n   * These are executed before controller and route guards\n   */\n  globalGuards?: any[]\n\n  /**\n   * Whether to enable versioning for API routes\n   * @default false\n   */\n  enableVersioning?: boolean\n\n  /**\n   * The versioning strategy to use\n   * @default \"uri\"\n   */\n  versioningStrategy?: 'uri' | 'header' | 'query'\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IRouterConfig {\n  /**\n   * Symbol for injecting the router config service\n   */\n  export const $ = Symbol.for('IRouterConfig')\n}\n","import type { HttpMethod } from '../../types'\nimport type { IParamMetadata } from './param-metadata.interface'\n\n/**\n * Interface for route definitions\n * Contains all metadata needed to register and handle a route\n */\nexport interface IRouteDefinition {\n  /**\n   * The HTTP method for the route (GET, POST, etc.)\n   */\n  method: HttpMethod\n\n  /**\n   * The route path relative to the controller prefix\n   */\n  path: string\n\n  /**\n   * The handler method name in the controller class\n   */\n  handlerName: string | symbol\n\n  /**\n   * The route-specific middleware (executed after controller middleware)\n   */\n  middleware: any[]\n\n  /**\n   * The route-specific guards (executed after controller guards)\n   */\n  guards: any[]\n\n  /**\n   * The parameter metadata for dependency injection\n   */\n  params: IParamMetadata[]\n\n  /**\n   * Additional metadata for custom extensions\n   */\n  metadata: Record<string, any>\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IRouteDefinition {\n  /**\n   * Symbol for injecting the route definition service\n   */\n  export const $ = Symbol.for('IRouteDefinition')\n}\n","import type { IRouteDefinition } from './route-definition.interface'\n\n/**\n * Interface for controller definitions\n * Contains all metadata needed to register and handle a controller\n */\nexport interface IControllerDefinition {\n  /**\n   * The controller constructor\n   */\n  controller: any\n\n  /**\n   * The route prefix for all routes in this controller\n   */\n  prefix: string\n\n  /**\n   * The controller-level middleware (applied to all routes)\n   */\n  middleware: any[]\n\n  /**\n   * The controller-level guards (applied to all routes)\n   */\n  guards: any[]\n\n  /**\n   * The controller routes\n   */\n  routes: IRouteDefinition[]\n\n  /**\n   * Additional metadata for custom extensions\n   */\n  metadata: Record<string, any>\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IControllerDefinition {\n  /**\n   * Symbol for injecting the controller definition service\n   */\n  export const $ = Symbol.for('IControllerDefinition')\n}\n","/**\n * Configuration environment\n */\nexport enum ConfigEnvironment {\n  /**\n   * Node.js environment\n   */\n  NODE = 'node',\n\n  /**\n   * Browser environment\n   */\n  BROWSER = 'browser',\n\n  /**\n   * Next.js environment\n   */\n  NEXTJS = 'nextjs',\n\n  /**\n   * React Native environment\n   */\n  REACT_NATIVE = 'react-native',\n\n  /**\n   * Unknown environment\n   */\n  UNKNOWN = 'unknown',\n}\n","/**\n * Worker status enum\n * Represents the possible states of a queue worker\n */\nexport enum WorkerStatus {\n  /**\n   * Worker is idle and ready to process jobs\n   */\n  IDLE = 'idle',\n\n  /**\n   * Worker is currently processing jobs\n   */\n  RUNNING = 'running',\n\n  /**\n   * Worker is paused and not processing jobs\n   */\n  PAUSED = 'paused',\n\n  /**\n   * Worker has been stopped\n   */\n  STOPPED = 'stopped',\n}\n","/**\n * Parameter type enum\n */\nexport enum ParamType {\n  /**\n   * Route parameter\n   */\n  PARAM = 'param',\n\n  /**\n   * Query parameter\n   */\n  QUERY = 'query',\n\n  /**\n   * Request body\n   */\n  BODY = 'body',\n\n  /**\n   * Request object\n   */\n  REQUEST = 'request',\n\n  /**\n   * Response object\n   */\n  RESPONSE = 'response',\n}\n","/**\n * Enum for question types\n *\n * Defines the types of questions that can be asked.\n */\nexport enum QuestionType {\n  /**\n   * Text input\n   */\n  Input = 'input',\n\n  /**\n   * Password input (masked)\n   */\n  Password = 'password',\n\n  /**\n   * Yes/no confirmation\n   */\n  Confirm = 'confirm',\n\n  /**\n   * Single selection from a list\n   */\n  List = 'list',\n\n  /**\n   * Multiple selection from a list\n   */\n  Checkbox = 'checkbox',\n\n  /**\n   * Numeric input\n   */\n  Number = 'number',\n\n  /**\n   * Multi-line text editor\n   */\n  Editor = 'editor',\n}\n"]}